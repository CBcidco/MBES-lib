        -:    0:Source:src/math/CoordinateTransform.hpp
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*
        -:    2: * Copyright 2018 © Centre Interdisciplinaire de développement en Cartographie des Océans (CIDCO), Tous droits réservés
        -:    3: */
        -:    4:
        -:    5:/*
        -:    6: * File:   CoordinateTransform.hpp
        -:    7: * Author: glm,jordan
        -:    8: *
        -:    9: * Created on September 13, 2018, 3:39 PM
        -:   10: */
        -:   11:
        -:   12:#ifndef COORDINATETRANSFORM_HPP
        -:   13:#define COORDINATETRANSFORM_HPP
        -:   14:
        -:   15:#include "../Position.hpp"
        -:   16:#include "../utils/Constants.hpp"
        -:   17:#include <Eigen/Dense>
        -:   18:
        -:   19:/*!
        -:   20: * \brief Coordinate transform class
        -:   21: */
        -:   22:class CoordinateTransform {
        -:   23:public:
        -:   24:
        -:   25:    // WGS84 ellipsoid Parameters
        -:   26:    
        -:   27:    /**WGS84 ellipsoid semi-major axis*/
        -:   28:    static constexpr double a = 6378137.0;
        -:   29:    
        -:   30:    /**WGS84 ellipsoid first eccentricity squared*/
        -:   31:    static constexpr double e2 = 0.081819190842622 * 0.081819190842622;
        -:   32:    
        -:   33:    /**WGS84 ellipsoid inverse flattening*/
        -:   34:    static constexpr double f = 1.0 / 298.257223563;
        -:   35:    
        -:   36:    /**WGS84 ellipsoid semi-minor axis*/
        -:   37:    static constexpr double b = a * (1-f); // semi-minor axis
        -:   38:    
        -:   39:    /**WGS84 ellipsoid second eccentricity squared*/
        -:   40:    static constexpr double epsilon = e2 / (1.0 - e2); // second eccentricity squared
        -:   41:
        -:   42:    /**
        -:   43:     * set the position in navigation frame
        -:   44:     * 
        -:   45:     * @param positionInNavigationFrame the value who need to be set
        -:   46:     * @param positionGeographic the geographic position
        -:   47:     * @param navDCM the rotation matrix
        -:   48:     * @param originECEF the ECEF origin position
        -:   49:     */
    #####:   50:    static void getPositionInNavigationFrame(Eigen::Vector3d & positionInNavigationFrame, Position & positionGeographic, Eigen::Matrix3d & navDCM, Eigen::Vector3d & originECEF) {
    #####:   51:        Eigen::Vector3d positionECEF;
    #####:   52:        getPositionECEF(positionECEF, positionGeographic);
        -:   53:
    #####:   54:        Eigen::Vector3d positionVector = navDCM * (positionECEF - originECEF);
        -:   55:
    #####:   56:        positionInNavigationFrame << positionVector(0), positionVector(1), positionVector(2);
    #####:   57:    };
        -:   58:
        -:   59:    /**
        -:   60:     * set the ECEF position by the given position
        -:   61:     * 
        -:   62:     * @param positionECEF value who need to be set
        -:   63:     * @param position the position use to get the ECEF position
        -:   64:     */
    #####:   65:    static void getPositionECEF(Eigen::Vector3d & positionECEF, Position & position) {
    #####:   66:        double N = a / (sqrt(1 - e2 * position.getSlat() * position.getSlat()));
    #####:   67:        double xTRF = (N + position.getEllipsoidalHeight()) * position.getClat() * position.getClon();
    #####:   68:        double yTRF = (N + position.getEllipsoidalHeight()) * position.getClat() * position.getSlon();
    #####:   69:        double zTRF = (N * (1 - e2) + position.getEllipsoidalHeight()) * position.getSlat();
        -:   70:
    #####:   71:        positionECEF << xTRF, yTRF, zTRF;
    #####:   72:    };
        -:   73:
        -:   74:    /**
        -:   75:     * Get the longitude latitude and elevation of a ECEF position
        -:   76:     * 
        -:   77:     * @param positionInNavigationFrame position who we need to get the latitude, longitude and elevation
        -:   78:     * @param positionGeographic the position where the latitude, longitude et elevation will be put
        -:   79:     */
    #####:   80:    static void convertECEFToLongitudeLatitudeElevation(Eigen::Vector3d & positionInNavigationFrame, Position & positionGeographic) {
    #####:   81:        double x = positionInNavigationFrame(0);
    #####:   82:        double y = positionInNavigationFrame(1);
    #####:   83:        double z = positionInNavigationFrame(2);
        -:   84:
        -:   85:        // Bowring (1985) algorithm
    #####:   86:        double p2 = x * x + y*y;
    #####:   87:        double r2 = p2 + z*z;
    #####:   88:        double p = std::sqrt(p2);
    #####:   89:        double r = std::sqrt(r2);
        -:   90:
    #####:   91:        double tanu = (1 - f) * (z / p) * (1 + epsilon * b / r);
    #####:   92:        double tan2u = tanu * tanu;
        -:   93:
    #####:   94:        double cos2u = 1.0 / (1.0 + tan2u);
    #####:   95:        double cosu = std::sqrt(cos2u);
    #####:   96:        double cos3u = cos2u * cosu;
        -:   97:
    #####:   98:        double sinu = tanu * cosu;
    #####:   99:        double sin2u = 1.0 - cos2u;
    #####:  100:        double sin3u = sin2u * sinu;
        -:  101:
    #####:  102:        double tanlat = (z + epsilon * b * sin3u) / (p - e2 * a * cos3u);
    #####:  103:        double tan2lat = tanlat * tanlat;
    #####:  104:        double cos2lat = 1.0 / (1.0 + tan2lat);
    #####:  105:        double sin2lat = 1.0 - cos2lat;
        -:  106:
    #####:  107:        double coslat = std::sqrt(cos2lat);
    #####:  108:        double sinlat = tanlat * coslat;
        -:  109:
    #####:  110:        double longitude = std::atan2(y, x);
    #####:  111:        double latitude = std::atan(tanlat);
    #####:  112:        double height = p * coslat + z * sinlat - a * sqrt(1.0 - e2 * sin2lat);
        -:  113:
    #####:  114:        positionGeographic.setLatitude(latitude*R2D);
    #####:  115:        positionGeographic.setLongitude(longitude*R2D);
    #####:  116:        positionGeographic.setEllipsoidalHeight(height);
    #####:  117:    }
        -:  118:
        -:  119:    /**
        -:  120:     * set a terrestial to local geodetic reference frame matrix by the given position
        -:  121:     * 
        -:  122:     * @param trf2lgf the terrestial to local geodetic reference frame matrix who need to be set
        -:  123:     * @param position the given position
        -:  124:     */
    #####:  125:    static void getTerrestialToLocalGeodeticReferenceFrameMatrix(Eigen::Matrix3d & trf2lgf, Position & position) {
    #####:  126:        double m00 = -position.getSlat() * position.getClon();
    #####:  127:        double m01 = -position.getSlat() * position.getSlon();
    #####:  128:        double m02 = position.getClat();
        -:  129:
    #####:  130:        double m10 = -position.getSlon();
    #####:  131:        double m11 = position.getClon();
    #####:  132:        double m12 = 0;
        -:  133:
    #####:  134:        double m20 = -position.getClat() * position.getClon();
    #####:  135:        double m21 = -position.getClat() * position.getSlon();
    #####:  136:        double m22 = -position.getSlat();
        -:  137:
    #####:  138:        trf2lgf <<
    #####:  139:                m00, m01, m02,
    #####:  140:                m10, m11, m12,
    #####:  141:                m20, m21, m22;
    #####:  142:    };
        -:  143:
        -:  144:    /**
        -:  145:     * Set rotation matrix from neutral/zero position to the given attitude
        -:  146:     * 
        -:  147:     * @param outputMatrix matrix who need to be set
        -:  148:     * @param attitude the given attitude
        -:  149:     */
    #####:  150:    static void getDCM(Eigen::Matrix3d & outputMatrix,Attitude & attitude){
    #####:  151:        outputMatrix <<         attitude.getCh()*attitude.getCp(),   attitude.getCh()*attitude.getSp()*attitude.getSr()-attitude.getCr()*attitude.getSh(), attitude.getCh()*attitude.getCr()*attitude.getSp()+attitude.getSr()*attitude.getSh(),
    #####:  152:                                attitude.getCp()*attitude.getSh(),   attitude.getCh()*attitude.getCr()+attitude.getSp()*attitude.getSr()*attitude.getSh(), attitude.getSh()*attitude.getCr()*attitude.getSp()-attitude.getCh()*attitude.getSr(),
    #####:  153:                                -attitude.getSp(),          attitude.getCp()*attitude.getSr(),        attitude.getCr()*attitude.getCp();
    #####:  154:    }
        -:  155:
        -:  156:
        -:  157:    /**
        -:  158:     * NED Tangent plane at position to WGS84 ECEF
        -:  159:     * 
        -:  160:     * @param outputMatrix the matrix who need to be set
        -:  161:     * @param position the position to convert
        -:  162:     */
    #####:  163:    static void ned2ecef(Eigen::Matrix3d & outputMatrix,Position & position){
        -:  164:
    #####:  165:        outputMatrix << -position.getClon()*position.getSlat(),-position.getSlon(),-position.getClat()*position.getClon(),
    #####:  166:                        -position.getSlat()*position.getSlon(),position.getClon(),-position.getClat()*position.getSlon(),
    #####:  167:                         position.getClat(),0,-position.getSlat();
        -:  168:
    #####:  169:    }
        -:  170:
        -:  171:
        -:  172:    /**
        -:  173:     * Converts spherical coordinates to cartesian
        -:  174:     * 
        -:  175:     * @param outputVector the cartesian coordinates
        -:  176:     * @param theta the polar angle
        -:  177:     * @param phi the azimuthal angle
        -:  178:     * @param r the radial distance
        -:  179:     */
    #####:  180:    static void spherical2cartesian(Eigen::Vector3d & outputVector,double theta,double phi,double r){
    #####:  181:	outputVector(0) = r * sin(D2R*theta)*cos(D2R*phi);
    #####:  182:	outputVector(1) = r * sin(D2R*theta)*sin(D2R*phi);
    #####:  183:	outputVector(2) = r * cos(D2R*theta);
    #####:  184:    }
        -:  185:
        -:  186:    /**
        -:  187:     * Converts sonar coordinates (alpha,beta,r) to cartesian (NED)
        -:  188:     * 
        -:  189:     * @param outputVector the cartesian coordinates
        -:  190:     * @param aphaDegrees the alpha degree
        -:  191:     * @param betaDegrees the beta degree
        -:  192:     * @param r the radical distance
        -:  193:     */
        -:  194:     static void sonar2cartesian(Eigen::Vector3d & outputVector,double alphaDegrees,double betaDegrees,double r){
        -:  195:        //FIXME: This is just for quick testing purposes and assumes a null tilt angle
        -:  196:
        -:  197:        outputVector(0)=0;
        -:  198:        outputVector(1)=(r/sin(D2R*(double)90)) * sin(D2R*betaDegrees);
        -:  199:        outputVector(2)=(r/sin(D2R*(double)90)) * sin(D2R*((double)90-betaDegrees));
        -:  200:     }
        -:  201:};
        -:  202:
        -:  203:#endif /* COORDINATETRANSFORM_HPP */
