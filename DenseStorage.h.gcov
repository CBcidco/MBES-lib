        -:    0:Source:/usr/include/eigen3/Eigen/src/Core/DenseStorage.h
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:// This file is part of Eigen, a lightweight C++ template library
        -:    2:// for linear algebra.
        -:    3://
        -:    4:// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>
        -:    5:// Copyright (C) 2006-2009 Benoit Jacob <jacob.benoit.1@gmail.com>
        -:    6:// Copyright (C) 2010-2013 Hauke Heibel <hauke.heibel@gmail.com>
        -:    7://
        -:    8:// This Source Code Form is subject to the terms of the Mozilla
        -:    9:// Public License v. 2.0. If a copy of the MPL was not distributed
        -:   10:// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
        -:   11:
        -:   12:#ifndef EIGEN_MATRIXSTORAGE_H
        -:   13:#define EIGEN_MATRIXSTORAGE_H
        -:   14:
        -:   15:#ifdef EIGEN_DENSE_STORAGE_CTOR_PLUGIN
        -:   16:  #define EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN EIGEN_DENSE_STORAGE_CTOR_PLUGIN;
        -:   17:#else
        -:   18:  #define EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
        -:   19:#endif
        -:   20:
        -:   21:namespace Eigen {
        -:   22:
        -:   23:namespace internal {
        -:   24:
        -:   25:struct constructor_without_unaligned_array_assert {};
        -:   26:
        -:   27:template<typename T, int Size>
        -:   28:EIGEN_DEVICE_FUNC
    #####:   29:void check_static_allocation_size()
        -:   30:{
        -:   31:  // if EIGEN_STACK_ALLOCATION_LIMIT is defined to 0, then no limit
        -:   32:  #if EIGEN_STACK_ALLOCATION_LIMIT
        -:   33:  EIGEN_STATIC_ASSERT(Size * sizeof(T) <= EIGEN_STACK_ALLOCATION_LIMIT, OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG);
        -:   34:  #endif
    #####:   35:}
        -:   36:
        -:   37:/** \internal
        -:   38:  * Static array. If the MatrixOrArrayOptions require auto-alignment, the array will be automatically aligned:
        -:   39:  * to 16 bytes boundary if the total size is a multiple of 16 bytes.
        -:   40:  */
        -:   41:template <typename T, int Size, int MatrixOrArrayOptions,
        -:   42:          int Alignment = (MatrixOrArrayOptions&DontAlign) ? 0
        -:   43:                        : compute_default_alignment<T,Size>::value >
        -:   44:struct plain_array
        -:   45:{
        -:   46:  T array[Size];
        -:   47:
        -:   48:  EIGEN_DEVICE_FUNC
    #####:   49:  plain_array()
        -:   50:  { 
    #####:   51:    check_static_allocation_size<T,Size>();
    #####:   52:  }
        -:   53:
        -:   54:  EIGEN_DEVICE_FUNC
        -:   55:  plain_array(constructor_without_unaligned_array_assert)
        -:   56:  { 
        -:   57:    check_static_allocation_size<T,Size>();
        -:   58:  }
        -:   59:};
        -:   60:
        -:   61:#if defined(EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT)
        -:   62:  #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask)
        -:   63:#elif EIGEN_GNUC_AT_LEAST(4,7) 
        -:   64:  // GCC 4.7 is too aggressive in its optimizations and remove the alignement test based on the fact the array is declared to be aligned.
        -:   65:  // See this bug report: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53900
        -:   66:  // Hiding the origin of the array pointer behind a function argument seems to do the trick even if the function is inlined:
        -:   67:  template<typename PtrType>
    #####:   68:  EIGEN_ALWAYS_INLINE PtrType eigen_unaligned_array_assert_workaround_gcc47(PtrType array) { return array; }
        -:   69:  #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask) \
        -:   70:    eigen_assert((internal::UIntPtr(eigen_unaligned_array_assert_workaround_gcc47(array)) & (sizemask)) == 0 \
        -:   71:              && "this assertion is explained here: " \
        -:   72:              "http://eigen.tuxfamily.org/dox-devel/group__TopicUnalignedArrayAssert.html" \
        -:   73:              " **** READ THIS WEB PAGE !!! ****");
        -:   74:#else
        -:   75:  #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask) \
        -:   76:    eigen_assert((internal::UIntPtr(array) & (sizemask)) == 0 \
        -:   77:              && "this assertion is explained here: " \
        -:   78:              "http://eigen.tuxfamily.org/dox-devel/group__TopicUnalignedArrayAssert.html" \
        -:   79:              " **** READ THIS WEB PAGE !!! ****");
        -:   80:#endif
        -:   81:
        -:   82:template <typename T, int Size, int MatrixOrArrayOptions>
        -:   83:struct plain_array<T, Size, MatrixOrArrayOptions, 8>
        -:   84:{
        -:   85:  EIGEN_ALIGN_TO_BOUNDARY(8) T array[Size];
        -:   86:
        -:   87:  EIGEN_DEVICE_FUNC
        -:   88:  plain_array() 
        -:   89:  {
        -:   90:    EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(7);
        -:   91:    check_static_allocation_size<T,Size>();
        -:   92:  }
        -:   93:
        -:   94:  EIGEN_DEVICE_FUNC
        -:   95:  plain_array(constructor_without_unaligned_array_assert) 
        -:   96:  { 
        -:   97:    check_static_allocation_size<T,Size>();
        -:   98:  }
        -:   99:};
        -:  100:
        -:  101:template <typename T, int Size, int MatrixOrArrayOptions>
        -:  102:struct plain_array<T, Size, MatrixOrArrayOptions, 16>
        -:  103:{
        -:  104:  EIGEN_ALIGN_TO_BOUNDARY(16) T array[Size];
        -:  105:
        -:  106:  EIGEN_DEVICE_FUNC
    #####:  107:  plain_array() 
        -:  108:  { 
    #####:  109:    EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(15);
    #####:  110:    check_static_allocation_size<T,Size>();
    #####:  111:  }
        -:  112:
        -:  113:  EIGEN_DEVICE_FUNC
        -:  114:  plain_array(constructor_without_unaligned_array_assert) 
        -:  115:  { 
        -:  116:    check_static_allocation_size<T,Size>();
        -:  117:  }
        -:  118:};
        -:  119:
        -:  120:template <typename T, int Size, int MatrixOrArrayOptions>
        -:  121:struct plain_array<T, Size, MatrixOrArrayOptions, 32>
        -:  122:{
        -:  123:  EIGEN_ALIGN_TO_BOUNDARY(32) T array[Size];
        -:  124:
        -:  125:  EIGEN_DEVICE_FUNC
        -:  126:  plain_array() 
        -:  127:  {
        -:  128:    EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(31);
        -:  129:    check_static_allocation_size<T,Size>();
        -:  130:  }
        -:  131:
        -:  132:  EIGEN_DEVICE_FUNC
        -:  133:  plain_array(constructor_without_unaligned_array_assert) 
        -:  134:  { 
        -:  135:    check_static_allocation_size<T,Size>();
        -:  136:  }
        -:  137:};
        -:  138:
        -:  139:template <typename T, int Size, int MatrixOrArrayOptions>
        -:  140:struct plain_array<T, Size, MatrixOrArrayOptions, 64>
        -:  141:{
        -:  142:  EIGEN_ALIGN_TO_BOUNDARY(64) T array[Size];
        -:  143:
        -:  144:  EIGEN_DEVICE_FUNC
        -:  145:  plain_array() 
        -:  146:  { 
        -:  147:    EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(63);
        -:  148:    check_static_allocation_size<T,Size>();
        -:  149:  }
        -:  150:
        -:  151:  EIGEN_DEVICE_FUNC
        -:  152:  plain_array(constructor_without_unaligned_array_assert) 
        -:  153:  { 
        -:  154:    check_static_allocation_size<T,Size>();
        -:  155:  }
        -:  156:};
        -:  157:
        -:  158:template <typename T, int MatrixOrArrayOptions, int Alignment>
        -:  159:struct plain_array<T, 0, MatrixOrArrayOptions, Alignment>
        -:  160:{
        -:  161:  T array[1];
        -:  162:  EIGEN_DEVICE_FUNC plain_array() {}
        -:  163:  EIGEN_DEVICE_FUNC plain_array(constructor_without_unaligned_array_assert) {}
        -:  164:};
        -:  165:
        -:  166:} // end namespace internal
        -:  167:
        -:  168:/** \internal
        -:  169:  *
        -:  170:  * \class DenseStorage
        -:  171:  * \ingroup Core_Module
        -:  172:  *
        -:  173:  * \brief Stores the data of a matrix
        -:  174:  *
        -:  175:  * This class stores the data of fixed-size, dynamic-size or mixed matrices
        -:  176:  * in a way as compact as possible.
        -:  177:  *
        -:  178:  * \sa Matrix
        -:  179:  */
        -:  180:template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage;
        -:  181:
        -:  182:// purely fixed-size matrix
        -:  183:template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage
        -:  184:{
        -:  185:    internal::plain_array<T,Size,_Options> m_data;
        -:  186:  public:
    #####:  187:    EIGEN_DEVICE_FUNC DenseStorage() {}
        -:  188:    EIGEN_DEVICE_FUNC
        -:  189:    explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
        -:  190:      : m_data(internal::constructor_without_unaligned_array_assert()) {}
        -:  191:    EIGEN_DEVICE_FUNC 
        -:  192:    DenseStorage(const DenseStorage& other) : m_data(other.m_data) {}
        -:  193:    EIGEN_DEVICE_FUNC 
        -:  194:    DenseStorage& operator=(const DenseStorage& other)
        -:  195:    { 
        -:  196:      if (this != &other) m_data = other.m_data;
        -:  197:      return *this; 
        -:  198:    }
        -:  199:    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) {
        -:  200:      EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
        -:  201:      eigen_internal_assert(size==rows*cols && rows==_Rows && cols==_Cols);
        -:  202:      EIGEN_UNUSED_VARIABLE(size);
        -:  203:      EIGEN_UNUSED_VARIABLE(rows);
        -:  204:      EIGEN_UNUSED_VARIABLE(cols);
        -:  205:    }
        -:  206:    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); }
    #####:  207:    EIGEN_DEVICE_FUNC static Index rows(void) {return _Rows;}
    #####:  208:    EIGEN_DEVICE_FUNC static Index cols(void) {return _Cols;}
        -:  209:    EIGEN_DEVICE_FUNC void conservativeResize(Index,Index,Index) {}
    #####:  210:    EIGEN_DEVICE_FUNC void resize(Index,Index,Index) {}
    #####:  211:    EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }
    #####:  212:    EIGEN_DEVICE_FUNC T *data() { return m_data.array; }
        -:  213:};
        -:  214:
        -:  215:// null matrix
        -:  216:template<typename T, int _Rows, int _Cols, int _Options> class DenseStorage<T, 0, _Rows, _Cols, _Options>
        -:  217:{
        -:  218:  public:
        -:  219:    EIGEN_DEVICE_FUNC DenseStorage() {}
        -:  220:    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert) {}
        -:  221:    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage&) {}
        -:  222:    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage&) { return *this; }
        -:  223:    EIGEN_DEVICE_FUNC DenseStorage(Index,Index,Index) {}
        -:  224:    EIGEN_DEVICE_FUNC void swap(DenseStorage& ) {}
        -:  225:    EIGEN_DEVICE_FUNC static Index rows(void) {return _Rows;}
        -:  226:    EIGEN_DEVICE_FUNC static Index cols(void) {return _Cols;}
        -:  227:    EIGEN_DEVICE_FUNC void conservativeResize(Index,Index,Index) {}
        -:  228:    EIGEN_DEVICE_FUNC void resize(Index,Index,Index) {}
        -:  229:    EIGEN_DEVICE_FUNC const T *data() const { return 0; }
        -:  230:    EIGEN_DEVICE_FUNC T *data() { return 0; }
        -:  231:};
        -:  232:
        -:  233:// more specializations for null matrices; these are necessary to resolve ambiguities
        -:  234:template<typename T, int _Options> class DenseStorage<T, 0, Dynamic, Dynamic, _Options>
        -:  235:: public DenseStorage<T, 0, 0, 0, _Options> { };
        -:  236:
        -:  237:template<typename T, int _Rows, int _Options> class DenseStorage<T, 0, _Rows, Dynamic, _Options>
        -:  238:: public DenseStorage<T, 0, 0, 0, _Options> { };
        -:  239:
        -:  240:template<typename T, int _Cols, int _Options> class DenseStorage<T, 0, Dynamic, _Cols, _Options>
        -:  241:: public DenseStorage<T, 0, 0, 0, _Options> { };
        -:  242:
        -:  243:// dynamic-size matrix with fixed-size storage
        -:  244:template<typename T, int Size, int _Options> class DenseStorage<T, Size, Dynamic, Dynamic, _Options>
        -:  245:{
        -:  246:    internal::plain_array<T,Size,_Options> m_data;
        -:  247:    Index m_rows;
        -:  248:    Index m_cols;
        -:  249:  public:
        -:  250:    EIGEN_DEVICE_FUNC DenseStorage() : m_rows(0), m_cols(0) {}
        -:  251:    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
        -:  252:      : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(0), m_cols(0) {}
        -:  253:    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows), m_cols(other.m_cols) {}
        -:  254:    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other) 
        -:  255:    { 
        -:  256:      if (this != &other)
        -:  257:      {
        -:  258:        m_data = other.m_data;
        -:  259:        m_rows = other.m_rows;
        -:  260:        m_cols = other.m_cols;
        -:  261:      }
        -:  262:      return *this; 
        -:  263:    }
        -:  264:    EIGEN_DEVICE_FUNC DenseStorage(Index, Index rows, Index cols) : m_rows(rows), m_cols(cols) {}
        -:  265:    EIGEN_DEVICE_FUNC void swap(DenseStorage& other)
        -:  266:    { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); std::swap(m_cols,other.m_cols); }
        -:  267:    EIGEN_DEVICE_FUNC Index rows() const {return m_rows;}
        -:  268:    EIGEN_DEVICE_FUNC Index cols() const {return m_cols;}
        -:  269:    EIGEN_DEVICE_FUNC void conservativeResize(Index, Index rows, Index cols) { m_rows = rows; m_cols = cols; }
        -:  270:    EIGEN_DEVICE_FUNC void resize(Index, Index rows, Index cols) { m_rows = rows; m_cols = cols; }
        -:  271:    EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }
        -:  272:    EIGEN_DEVICE_FUNC T *data() { return m_data.array; }
        -:  273:};
        -:  274:
        -:  275:// dynamic-size matrix with fixed-size storage and fixed width
        -:  276:template<typename T, int Size, int _Cols, int _Options> class DenseStorage<T, Size, Dynamic, _Cols, _Options>
        -:  277:{
        -:  278:    internal::plain_array<T,Size,_Options> m_data;
        -:  279:    Index m_rows;
        -:  280:  public:
        -:  281:    EIGEN_DEVICE_FUNC DenseStorage() : m_rows(0) {}
        -:  282:    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
        -:  283:      : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(0) {}
        -:  284:    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows) {}
        -:  285:    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other) 
        -:  286:    {
        -:  287:      if (this != &other)
        -:  288:      {
        -:  289:        m_data = other.m_data;
        -:  290:        m_rows = other.m_rows;
        -:  291:      }
        -:  292:      return *this; 
        -:  293:    }
        -:  294:    EIGEN_DEVICE_FUNC DenseStorage(Index, Index rows, Index) : m_rows(rows) {}
        -:  295:    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }
        -:  296:    EIGEN_DEVICE_FUNC Index rows(void) const {return m_rows;}
        -:  297:    EIGEN_DEVICE_FUNC Index cols(void) const {return _Cols;}
        -:  298:    EIGEN_DEVICE_FUNC void conservativeResize(Index, Index rows, Index) { m_rows = rows; }
        -:  299:    EIGEN_DEVICE_FUNC void resize(Index, Index rows, Index) { m_rows = rows; }
        -:  300:    EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }
        -:  301:    EIGEN_DEVICE_FUNC T *data() { return m_data.array; }
        -:  302:};
        -:  303:
        -:  304:// dynamic-size matrix with fixed-size storage and fixed height
        -:  305:template<typename T, int Size, int _Rows, int _Options> class DenseStorage<T, Size, _Rows, Dynamic, _Options>
        -:  306:{
        -:  307:    internal::plain_array<T,Size,_Options> m_data;
        -:  308:    Index m_cols;
        -:  309:  public:
        -:  310:    EIGEN_DEVICE_FUNC DenseStorage() : m_cols(0) {}
        -:  311:    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
        -:  312:      : m_data(internal::constructor_without_unaligned_array_assert()), m_cols(0) {}
        -:  313:    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_cols(other.m_cols) {}
        -:  314:    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)
        -:  315:    {
        -:  316:      if (this != &other)
        -:  317:      {
        -:  318:        m_data = other.m_data;
        -:  319:        m_cols = other.m_cols;
        -:  320:      }
        -:  321:      return *this;
        -:  322:    }
        -:  323:    EIGEN_DEVICE_FUNC DenseStorage(Index, Index, Index cols) : m_cols(cols) {}
        -:  324:    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }
        -:  325:    EIGEN_DEVICE_FUNC Index rows(void) const {return _Rows;}
        -:  326:    EIGEN_DEVICE_FUNC Index cols(void) const {return m_cols;}
        -:  327:    void conservativeResize(Index, Index, Index cols) { m_cols = cols; }
        -:  328:    void resize(Index, Index, Index cols) { m_cols = cols; }
        -:  329:    EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }
        -:  330:    EIGEN_DEVICE_FUNC T *data() { return m_data.array; }
        -:  331:};
        -:  332:
        -:  333:// purely dynamic matrix.
        -:  334:template<typename T, int _Options> class DenseStorage<T, Dynamic, Dynamic, Dynamic, _Options>
        -:  335:{
        -:  336:    T *m_data;
        -:  337:    Index m_rows;
        -:  338:    Index m_cols;
        -:  339:  public:
        -:  340:    EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}
        -:  341:    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
        -:  342:       : m_data(0), m_rows(0), m_cols(0) {}
        -:  343:    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols)
        -:  344:      : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows), m_cols(cols)
        -:  345:    {
        -:  346:      EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
        -:  347:      eigen_internal_assert(size==rows*cols && rows>=0 && cols >=0);
        -:  348:    }
        -:  349:    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)
        -:  350:      : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(other.m_rows*other.m_cols))
        -:  351:      , m_rows(other.m_rows)
        -:  352:      , m_cols(other.m_cols)
        -:  353:    {
        -:  354:      internal::smart_copy(other.m_data, other.m_data+other.m_rows*other.m_cols, m_data);
        -:  355:    }
        -:  356:    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)
        -:  357:    {
        -:  358:      if (this != &other)
        -:  359:      {
        -:  360:        DenseStorage tmp(other);
        -:  361:        this->swap(tmp);
        -:  362:      }
        -:  363:      return *this;
        -:  364:    }
        -:  365:#if EIGEN_HAS_RVALUE_REFERENCES
        -:  366:    EIGEN_DEVICE_FUNC
        -:  367:    DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT
        -:  368:      : m_data(std::move(other.m_data))
        -:  369:      , m_rows(std::move(other.m_rows))
        -:  370:      , m_cols(std::move(other.m_cols))
        -:  371:    {
        -:  372:      other.m_data = nullptr;
        -:  373:      other.m_rows = 0;
        -:  374:      other.m_cols = 0;
        -:  375:    }
        -:  376:    EIGEN_DEVICE_FUNC
        -:  377:    DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT
        -:  378:    {
        -:  379:      using std::swap;
        -:  380:      swap(m_data, other.m_data);
        -:  381:      swap(m_rows, other.m_rows);
        -:  382:      swap(m_cols, other.m_cols);
        -:  383:      return *this;
        -:  384:    }
        -:  385:#endif
        -:  386:    EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }
        -:  387:    EIGEN_DEVICE_FUNC void swap(DenseStorage& other)
        -:  388:    { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); std::swap(m_cols,other.m_cols); }
        -:  389:    EIGEN_DEVICE_FUNC Index rows(void) const {return m_rows;}
        -:  390:    EIGEN_DEVICE_FUNC Index cols(void) const {return m_cols;}
        -:  391:    void conservativeResize(Index size, Index rows, Index cols)
        -:  392:    {
        -:  393:      m_data = internal::conditional_aligned_realloc_new_auto<T,(_Options&DontAlign)==0>(m_data, size, m_rows*m_cols);
        -:  394:      m_rows = rows;
        -:  395:      m_cols = cols;
        -:  396:    }
        -:  397:    EIGEN_DEVICE_FUNC void resize(Index size, Index rows, Index cols)
        -:  398:    {
        -:  399:      if(size != m_rows*m_cols)
        -:  400:      {
        -:  401:        internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols);
        -:  402:        if (size)
        -:  403:          m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);
        -:  404:        else
        -:  405:          m_data = 0;
        -:  406:        EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
        -:  407:      }
        -:  408:      m_rows = rows;
        -:  409:      m_cols = cols;
        -:  410:    }
        -:  411:    EIGEN_DEVICE_FUNC const T *data() const { return m_data; }
        -:  412:    EIGEN_DEVICE_FUNC T *data() { return m_data; }
        -:  413:};
        -:  414:
        -:  415:// matrix with dynamic width and fixed height (so that matrix has dynamic size).
        -:  416:template<typename T, int _Rows, int _Options> class DenseStorage<T, Dynamic, _Rows, Dynamic, _Options>
        -:  417:{
        -:  418:    T *m_data;
        -:  419:    Index m_cols;
        -:  420:  public:
        -:  421:    EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_cols(0) {}
        -:  422:    explicit DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_cols(0) {}
        -:  423:    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_cols(cols)
        -:  424:    {
        -:  425:      EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
        -:  426:      eigen_internal_assert(size==rows*cols && rows==_Rows && cols >=0);
        -:  427:      EIGEN_UNUSED_VARIABLE(rows);
        -:  428:    }
        -:  429:    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)
        -:  430:      : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(_Rows*other.m_cols))
        -:  431:      , m_cols(other.m_cols)
        -:  432:    {
        -:  433:      internal::smart_copy(other.m_data, other.m_data+_Rows*m_cols, m_data);
        -:  434:    }
        -:  435:    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)
        -:  436:    {
        -:  437:      if (this != &other)
        -:  438:      {
        -:  439:        DenseStorage tmp(other);
        -:  440:        this->swap(tmp);
        -:  441:      }
        -:  442:      return *this;
        -:  443:    }    
        -:  444:#if EIGEN_HAS_RVALUE_REFERENCES
        -:  445:    EIGEN_DEVICE_FUNC
        -:  446:    DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT
        -:  447:      : m_data(std::move(other.m_data))
        -:  448:      , m_cols(std::move(other.m_cols))
        -:  449:    {
        -:  450:      other.m_data = nullptr;
        -:  451:      other.m_cols = 0;
        -:  452:    }
        -:  453:    EIGEN_DEVICE_FUNC
        -:  454:    DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT
        -:  455:    {
        -:  456:      using std::swap;
        -:  457:      swap(m_data, other.m_data);
        -:  458:      swap(m_cols, other.m_cols);
        -:  459:      return *this;
        -:  460:    }
        -:  461:#endif
        -:  462:    EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols); }
        -:  463:    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }
        -:  464:    EIGEN_DEVICE_FUNC static Index rows(void) {return _Rows;}
        -:  465:    EIGEN_DEVICE_FUNC Index cols(void) const {return m_cols;}
        -:  466:    EIGEN_DEVICE_FUNC void conservativeResize(Index size, Index, Index cols)
        -:  467:    {
        -:  468:      m_data = internal::conditional_aligned_realloc_new_auto<T,(_Options&DontAlign)==0>(m_data, size, _Rows*m_cols);
        -:  469:      m_cols = cols;
        -:  470:    }
        -:  471:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void resize(Index size, Index, Index cols)
        -:  472:    {
        -:  473:      if(size != _Rows*m_cols)
        -:  474:      {
        -:  475:        internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols);
        -:  476:        if (size)
        -:  477:          m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);
        -:  478:        else
        -:  479:          m_data = 0;
        -:  480:        EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
        -:  481:      }
        -:  482:      m_cols = cols;
        -:  483:    }
        -:  484:    EIGEN_DEVICE_FUNC const T *data() const { return m_data; }
        -:  485:    EIGEN_DEVICE_FUNC T *data() { return m_data; }
        -:  486:};
        -:  487:
        -:  488:// matrix with dynamic height and fixed width (so that matrix has dynamic size).
        -:  489:template<typename T, int _Cols, int _Options> class DenseStorage<T, Dynamic, Dynamic, _Cols, _Options>
        -:  490:{
        -:  491:    T *m_data;
        -:  492:    Index m_rows;
        -:  493:  public:
    #####:  494:    EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_rows(0) {}
        -:  495:    explicit DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0) {}
        -:  496:    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows)
        -:  497:    {
        -:  498:      EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
        -:  499:      eigen_internal_assert(size==rows*cols && rows>=0 && cols == _Cols);
        -:  500:      EIGEN_UNUSED_VARIABLE(cols);
        -:  501:    }
        -:  502:    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)
        -:  503:      : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(other.m_rows*_Cols))
        -:  504:      , m_rows(other.m_rows)
        -:  505:    {
        -:  506:      internal::smart_copy(other.m_data, other.m_data+other.m_rows*_Cols, m_data);
        -:  507:    }
        -:  508:    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)
        -:  509:    {
        -:  510:      if (this != &other)
        -:  511:      {
        -:  512:        DenseStorage tmp(other);
        -:  513:        this->swap(tmp);
        -:  514:      }
        -:  515:      return *this;
        -:  516:    }    
        -:  517:#if EIGEN_HAS_RVALUE_REFERENCES
        -:  518:    EIGEN_DEVICE_FUNC
        -:  519:    DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT
        -:  520:      : m_data(std::move(other.m_data))
        -:  521:      , m_rows(std::move(other.m_rows))
        -:  522:    {
        -:  523:      other.m_data = nullptr;
        -:  524:      other.m_rows = 0;
        -:  525:    }
        -:  526:    EIGEN_DEVICE_FUNC
        -:  527:    DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT
        -:  528:    {
        -:  529:      using std::swap;
        -:  530:      swap(m_data, other.m_data);
        -:  531:      swap(m_rows, other.m_rows);
        -:  532:      return *this;
        -:  533:    }
        -:  534:#endif
    #####:  535:    EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows); }
        -:  536:    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }
    #####:  537:    EIGEN_DEVICE_FUNC Index rows(void) const {return m_rows;}
    #####:  538:    EIGEN_DEVICE_FUNC static Index cols(void) {return _Cols;}
        -:  539:    void conservativeResize(Index size, Index rows, Index)
        -:  540:    {
        -:  541:      m_data = internal::conditional_aligned_realloc_new_auto<T,(_Options&DontAlign)==0>(m_data, size, m_rows*_Cols);
        -:  542:      m_rows = rows;
        -:  543:    }
    #####:  544:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void resize(Index size, Index rows, Index)
        -:  545:    {
    #####:  546:      if(size != m_rows*_Cols)
        -:  547:      {
    #####:  548:        internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows);
    #####:  549:        if (size)
    #####:  550:          m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);
        -:  551:        else
    #####:  552:          m_data = 0;
        -:  553:        EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
        -:  554:      }
    #####:  555:      m_rows = rows;
    #####:  556:    }
    #####:  557:    EIGEN_DEVICE_FUNC const T *data() const { return m_data; }
        -:  558:    EIGEN_DEVICE_FUNC T *data() { return m_data; }
        -:  559:};
        -:  560:
        -:  561:} // end namespace Eigen
        -:  562:
        -:  563:#endif // EIGEN_MATRIX_H
