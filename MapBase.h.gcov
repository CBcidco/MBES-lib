        -:    0:Source:/usr/include/eigen3/Eigen/src/Core/MapBase.h
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:// This file is part of Eigen, a lightweight C++ template library
        -:    2:// for linear algebra.
        -:    3://
        -:    4:// Copyright (C) 2007-2010 Benoit Jacob <jacob.benoit.1@gmail.com>
        -:    5:// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>
        -:    6://
        -:    7:// This Source Code Form is subject to the terms of the Mozilla
        -:    8:// Public License v. 2.0. If a copy of the MPL was not distributed
        -:    9:// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
        -:   10:
        -:   11:#ifndef EIGEN_MAPBASE_H
        -:   12:#define EIGEN_MAPBASE_H
        -:   13:
        -:   14:#define EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS(Derived) \
        -:   15:      EIGEN_STATIC_ASSERT((int(internal::evaluator<Derived>::Flags) & LinearAccessBit) || Derived::IsVectorAtCompileTime, \
        -:   16:                          YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT)
        -:   17:
        -:   18:namespace Eigen { 
        -:   19:
        -:   20:/** \ingroup Core_Module
        -:   21:  *
        -:   22:  * \brief Base class for dense Map and Block expression with direct access
        -:   23:  *
        -:   24:  * This base class provides the const low-level accessors (e.g. coeff, coeffRef) of dense
        -:   25:  * Map and Block objects with direct access.
        -:   26:  * Typical users do not have to directly deal with this class.
        -:   27:  *
        -:   28:  * This class can be extended by through the macro plugin \c EIGEN_MAPBASE_PLUGIN.
        -:   29:  * See \link TopicCustomizing_Plugins customizing Eigen \endlink for details.
        -:   30:  *
        -:   31:  * The \c Derived class has to provide the following two methods describing the memory layout:
        -:   32:  *  \code Index innerStride() const; \endcode
        -:   33:  *  \code Index outerStride() const; \endcode
        -:   34:  *
        -:   35:  * \sa class Map, class Block
        -:   36:  */
    #####:   37:template<typename Derived> class MapBase<Derived, ReadOnlyAccessors>
        -:   38:  : public internal::dense_xpr_base<Derived>::type
        -:   39:{
        -:   40:  public:
        -:   41:
        -:   42:    typedef typename internal::dense_xpr_base<Derived>::type Base;
        -:   43:    enum {
        -:   44:      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,
        -:   45:      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,
        -:   46:      SizeAtCompileTime = Base::SizeAtCompileTime
        -:   47:    };
        -:   48:
        -:   49:    typedef typename internal::traits<Derived>::StorageKind StorageKind;
        -:   50:    typedef typename internal::traits<Derived>::Scalar Scalar;
        -:   51:    typedef typename internal::packet_traits<Scalar>::type PacketScalar;
        -:   52:    typedef typename NumTraits<Scalar>::Real RealScalar;
        -:   53:    typedef typename internal::conditional<
        -:   54:                         bool(internal::is_lvalue<Derived>::value),
        -:   55:                         Scalar *,
        -:   56:                         const Scalar *>::type
        -:   57:                     PointerType;
        -:   58:
        -:   59:    using Base::derived;
        -:   60://    using Base::RowsAtCompileTime;
        -:   61://    using Base::ColsAtCompileTime;
        -:   62://    using Base::SizeAtCompileTime;
        -:   63:    using Base::MaxRowsAtCompileTime;
        -:   64:    using Base::MaxColsAtCompileTime;
        -:   65:    using Base::MaxSizeAtCompileTime;
        -:   66:    using Base::IsVectorAtCompileTime;
        -:   67:    using Base::Flags;
        -:   68:    using Base::IsRowMajor;
        -:   69:
        -:   70:    using Base::rows;
        -:   71:    using Base::cols;
        -:   72:    using Base::size;
        -:   73:    using Base::coeff;
        -:   74:    using Base::coeffRef;
        -:   75:    using Base::lazyAssign;
        -:   76:    using Base::eval;
        -:   77:
        -:   78:    using Base::innerStride;
        -:   79:    using Base::outerStride;
        -:   80:    using Base::rowStride;
        -:   81:    using Base::colStride;
        -:   82:
        -:   83:    // bug 217 - compile error on ICC 11.1
        -:   84:    using Base::operator=;
        -:   85:
        -:   86:    typedef typename Base::CoeffReturnType CoeffReturnType;
        -:   87:
        -:   88:    /** \copydoc DenseBase::rows() */
    #####:   89:    EIGEN_DEVICE_FUNC inline Index rows() const { return m_rows.value(); }
        -:   90:    /** \copydoc DenseBase::cols() */
    #####:   91:    EIGEN_DEVICE_FUNC inline Index cols() const { return m_cols.value(); }
        -:   92:
        -:   93:    /** Returns a pointer to the first coefficient of the matrix or vector.
        -:   94:      *
        -:   95:      * \note When addressing this data, make sure to honor the strides returned by innerStride() and outerStride().
        -:   96:      *
        -:   97:      * \sa innerStride(), outerStride()
        -:   98:      */
    #####:   99:    EIGEN_DEVICE_FUNC inline const Scalar* data() const { return m_data; }
        -:  100:
        -:  101:    /** \copydoc PlainObjectBase::coeff(Index,Index) const */
        -:  102:    EIGEN_DEVICE_FUNC
        -:  103:    inline const Scalar& coeff(Index rowId, Index colId) const
        -:  104:    {
        -:  105:      return m_data[colId * colStride() + rowId * rowStride()];
        -:  106:    }
        -:  107:
        -:  108:    /** \copydoc PlainObjectBase::coeff(Index) const */
        -:  109:    EIGEN_DEVICE_FUNC
        -:  110:    inline const Scalar& coeff(Index index) const
        -:  111:    {
        -:  112:      EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS(Derived)
        -:  113:      return m_data[index * innerStride()];
        -:  114:    }
        -:  115:
        -:  116:    /** \copydoc PlainObjectBase::coeffRef(Index,Index) const */
        -:  117:    EIGEN_DEVICE_FUNC
        -:  118:    inline const Scalar& coeffRef(Index rowId, Index colId) const
        -:  119:    {
        -:  120:      return this->m_data[colId * colStride() + rowId * rowStride()];
        -:  121:    }
        -:  122:
        -:  123:    /** \copydoc PlainObjectBase::coeffRef(Index) const */
        -:  124:    EIGEN_DEVICE_FUNC
        -:  125:    inline const Scalar& coeffRef(Index index) const
        -:  126:    {
        -:  127:      EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS(Derived)
        -:  128:      return this->m_data[index * innerStride()];
        -:  129:    }
        -:  130:
        -:  131:    /** \internal */
        -:  132:    template<int LoadMode>
        -:  133:    inline PacketScalar packet(Index rowId, Index colId) const
        -:  134:    {
        -:  135:      return internal::ploadt<PacketScalar, LoadMode>
        -:  136:               (m_data + (colId * colStride() + rowId * rowStride()));
        -:  137:    }
        -:  138:
        -:  139:    /** \internal */
        -:  140:    template<int LoadMode>
        -:  141:    inline PacketScalar packet(Index index) const
        -:  142:    {
        -:  143:      EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS(Derived)
        -:  144:      return internal::ploadt<PacketScalar, LoadMode>(m_data + index * innerStride());
        -:  145:    }
        -:  146:
        -:  147:    /** \internal Constructor for fixed size matrices or vectors */
        -:  148:    EIGEN_DEVICE_FUNC
        -:  149:    explicit inline MapBase(PointerType dataPtr) : m_data(dataPtr), m_rows(RowsAtCompileTime), m_cols(ColsAtCompileTime)
        -:  150:    {
        -:  151:      EIGEN_STATIC_ASSERT_FIXED_SIZE(Derived)
        -:  152:      checkSanity<Derived>();
        -:  153:    }
        -:  154:
        -:  155:    /** \internal Constructor for dynamically sized vectors */
        -:  156:    EIGEN_DEVICE_FUNC
        -:  157:    inline MapBase(PointerType dataPtr, Index vecSize)
        -:  158:            : m_data(dataPtr),
        -:  159:              m_rows(RowsAtCompileTime == Dynamic ? vecSize : Index(RowsAtCompileTime)),
        -:  160:              m_cols(ColsAtCompileTime == Dynamic ? vecSize : Index(ColsAtCompileTime))
        -:  161:    {
        -:  162:      EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived)
        -:  163:      eigen_assert(vecSize >= 0);
        -:  164:      eigen_assert(dataPtr == 0 || SizeAtCompileTime == Dynamic || SizeAtCompileTime == vecSize);
        -:  165:      checkSanity<Derived>();
        -:  166:    }
        -:  167:
        -:  168:    /** \internal Constructor for dynamically sized matrices */
        -:  169:    EIGEN_DEVICE_FUNC
    #####:  170:    inline MapBase(PointerType dataPtr, Index rows, Index cols)
    #####:  171:            : m_data(dataPtr), m_rows(rows), m_cols(cols)
        -:  172:    {
    #####:  173:      eigen_assert( (dataPtr == 0)
        -:  174:              || (   rows >= 0 && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows)
        -:  175:                  && cols >= 0 && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == cols)));
    #####:  176:      checkSanity<Derived>();
    #####:  177:    }
        -:  178:
        -:  179:    #ifdef EIGEN_MAPBASE_PLUGIN
        -:  180:    #include EIGEN_MAPBASE_PLUGIN
        -:  181:    #endif
        -:  182:
        -:  183:  protected:
        -:  184:
        -:  185:    template<typename T>
        -:  186:    EIGEN_DEVICE_FUNC
        -:  187:    void checkSanity(typename internal::enable_if<(internal::traits<T>::Alignment>0),void*>::type = 0) const
        -:  188:    {
        -:  189:#if EIGEN_MAX_ALIGN_BYTES>0
        -:  190:      eigen_assert((   ((internal::UIntPtr(m_data) % internal::traits<Derived>::Alignment) == 0)
        -:  191:                    || (cols() * rows() * innerStride() * sizeof(Scalar)) < internal::traits<Derived>::Alignment ) && "data is not aligned");
        -:  192:#endif
        -:  193:    }
        -:  194:
        -:  195:    template<typename T>
        -:  196:    EIGEN_DEVICE_FUNC
    #####:  197:    void checkSanity(typename internal::enable_if<internal::traits<T>::Alignment==0,void*>::type = 0) const
    #####:  198:    {}
        -:  199:
        -:  200:    PointerType m_data;
        -:  201:    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;
        -:  202:    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;
        -:  203:};
        -:  204:
        -:  205:/** \ingroup Core_Module
        -:  206:  *
        -:  207:  * \brief Base class for non-const dense Map and Block expression with direct access
        -:  208:  *
        -:  209:  * This base class provides the non-const low-level accessors (e.g. coeff and coeffRef) of
        -:  210:  * dense Map and Block objects with direct access.
        -:  211:  * It inherits MapBase<Derived, ReadOnlyAccessors> which defines the const variant for reading specific entries.
        -:  212:  *
        -:  213:  * \sa class Map, class Block
        -:  214:  */
        -:  215:template<typename Derived> class MapBase<Derived, WriteAccessors>
        -:  216:  : public MapBase<Derived, ReadOnlyAccessors>
        -:  217:{
        -:  218:    typedef MapBase<Derived, ReadOnlyAccessors> ReadOnlyMapBase;
        -:  219:  public:
        -:  220:
        -:  221:    typedef MapBase<Derived, ReadOnlyAccessors> Base;
        -:  222:
        -:  223:    typedef typename Base::Scalar Scalar;
        -:  224:    typedef typename Base::PacketScalar PacketScalar;
        -:  225:    typedef typename Base::StorageIndex StorageIndex;
        -:  226:    typedef typename Base::PointerType PointerType;
        -:  227:
        -:  228:    using Base::derived;
        -:  229:    using Base::rows;
        -:  230:    using Base::cols;
        -:  231:    using Base::size;
        -:  232:    using Base::coeff;
        -:  233:    using Base::coeffRef;
        -:  234:
        -:  235:    using Base::innerStride;
        -:  236:    using Base::outerStride;
        -:  237:    using Base::rowStride;
        -:  238:    using Base::colStride;
        -:  239:
        -:  240:    typedef typename internal::conditional<
        -:  241:                    internal::is_lvalue<Derived>::value,
        -:  242:                    Scalar,
        -:  243:                    const Scalar
        -:  244:                  >::type ScalarWithConstIfNotLvalue;
        -:  245:
        -:  246:    EIGEN_DEVICE_FUNC
    #####:  247:    inline const Scalar* data() const { return this->m_data; }
        -:  248:    EIGEN_DEVICE_FUNC
        -:  249:    inline ScalarWithConstIfNotLvalue* data() { return this->m_data; } // no const-cast here so non-const-correct code will give a compile error
        -:  250:
        -:  251:    EIGEN_DEVICE_FUNC
        -:  252:    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)
        -:  253:    {
        -:  254:      return this->m_data[col * colStride() + row * rowStride()];
        -:  255:    }
        -:  256:
        -:  257:    EIGEN_DEVICE_FUNC
        -:  258:    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)
        -:  259:    {
        -:  260:      EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS(Derived)
        -:  261:      return this->m_data[index * innerStride()];
        -:  262:    }
        -:  263:
        -:  264:    template<int StoreMode>
        -:  265:    inline void writePacket(Index row, Index col, const PacketScalar& val)
        -:  266:    {
        -:  267:      internal::pstoret<Scalar, PacketScalar, StoreMode>
        -:  268:               (this->m_data + (col * colStride() + row * rowStride()), val);
        -:  269:    }
        -:  270:
        -:  271:    template<int StoreMode>
        -:  272:    inline void writePacket(Index index, const PacketScalar& val)
        -:  273:    {
        -:  274:      EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS(Derived)
        -:  275:      internal::pstoret<Scalar, PacketScalar, StoreMode>
        -:  276:                (this->m_data + index * innerStride(), val);
        -:  277:    }
        -:  278:
        -:  279:    EIGEN_DEVICE_FUNC explicit inline MapBase(PointerType dataPtr) : Base(dataPtr) {}
        -:  280:    EIGEN_DEVICE_FUNC inline MapBase(PointerType dataPtr, Index vecSize) : Base(dataPtr, vecSize) {}
    #####:  281:    EIGEN_DEVICE_FUNC inline MapBase(PointerType dataPtr, Index rows, Index cols) : Base(dataPtr, rows, cols) {}
        -:  282:
        -:  283:    EIGEN_DEVICE_FUNC
        -:  284:    Derived& operator=(const MapBase& other)
        -:  285:    {
        -:  286:      ReadOnlyMapBase::Base::operator=(other);
        -:  287:      return derived();
        -:  288:    }
        -:  289:
        -:  290:    // In theory we could simply refer to Base:Base::operator=, but MSVC does not like Base::Base,
        -:  291:    // see bugs 821 and 920.
        -:  292:    using ReadOnlyMapBase::Base::operator=;
        -:  293:};
        -:  294:
        -:  295:#undef EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS
        -:  296:
        -:  297:} // end namespace Eigen
        -:  298:
        -:  299:#endif // EIGEN_MAPBASE_H
