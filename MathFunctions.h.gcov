        -:    0:Source:/usr/include/eigen3/Eigen/src/Core/MathFunctions.h
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:// This file is part of Eigen, a lightweight C++ template library
        -:    2:// for linear algebra.
        -:    3://
        -:    4:// Copyright (C) 2006-2010 Benoit Jacob <jacob.benoit.1@gmail.com>
        -:    5://
        -:    6:// This Source Code Form is subject to the terms of the Mozilla
        -:    7:// Public License v. 2.0. If a copy of the MPL was not distributed
        -:    8:// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
        -:    9:
        -:   10:#ifndef EIGEN_MATHFUNCTIONS_H
        -:   11:#define EIGEN_MATHFUNCTIONS_H
        -:   12:
        -:   13:// source: http://www.geom.uiuc.edu/~huberty/math5337/groupe/digits.html
        -:   14:// TODO this should better be moved to NumTraits
        -:   15:#define EIGEN_PI 3.141592653589793238462643383279502884197169399375105820974944592307816406L
        -:   16:
        -:   17:
        -:   18:namespace Eigen {
        -:   19:
        -:   20:// On WINCE, std::abs is defined for int only, so let's defined our own overloads:
        -:   21:// This issue has been confirmed with MSVC 2008 only, but the issue might exist for more recent versions too.
        -:   22:#if EIGEN_OS_WINCE && EIGEN_COMP_MSVC && EIGEN_COMP_MSVC<=1500
        -:   23:long        abs(long        x) { return (labs(x));  }
        -:   24:double      abs(double      x) { return (fabs(x));  }
        -:   25:float       abs(float       x) { return (fabsf(x)); }
        -:   26:long double abs(long double x) { return (fabsl(x)); }
        -:   27:#endif
        -:   28:
        -:   29:namespace internal {
        -:   30:
        -:   31:/** \internal \class global_math_functions_filtering_base
        -:   32:  *
        -:   33:  * What it does:
        -:   34:  * Defines a typedef 'type' as follows:
        -:   35:  * - if type T has a member typedef Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl, then
        -:   36:  *   global_math_functions_filtering_base<T>::type is a typedef for it.
        -:   37:  * - otherwise, global_math_functions_filtering_base<T>::type is a typedef for T.
        -:   38:  *
        -:   39:  * How it's used:
        -:   40:  * To allow to defined the global math functions (like sin...) in certain cases, like the Array expressions.
        -:   41:  * When you do sin(array1+array2), the object array1+array2 has a complicated expression type, all what you want to know
        -:   42:  * is that it inherits ArrayBase. So we implement a partial specialization of sin_impl for ArrayBase<Derived>.
        -:   43:  * So we must make sure to use sin_impl<ArrayBase<Derived> > and not sin_impl<Derived>, otherwise our partial specialization
        -:   44:  * won't be used. How does sin know that? That's exactly what global_math_functions_filtering_base tells it.
        -:   45:  *
        -:   46:  * How it's implemented:
        -:   47:  * SFINAE in the style of enable_if. Highly susceptible of breaking compilers. With GCC, it sure does work, but if you replace
        -:   48:  * the typename dummy by an integer template parameter, it doesn't work anymore!
        -:   49:  */
        -:   50:
        -:   51:template<typename T, typename dummy = void>
        -:   52:struct global_math_functions_filtering_base
        -:   53:{
        -:   54:  typedef T type;
        -:   55:};
        -:   56:
        -:   57:template<typename T> struct always_void { typedef void type; };
        -:   58:
        -:   59:template<typename T>
        -:   60:struct global_math_functions_filtering_base
        -:   61:  <T,
        -:   62:   typename always_void<typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl>::type
        -:   63:  >
        -:   64:{
        -:   65:  typedef typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl type;
        -:   66:};
        -:   67:
        -:   68:#define EIGEN_MATHFUNC_IMPL(func, scalar) Eigen::internal::func##_impl<typename Eigen::internal::global_math_functions_filtering_base<scalar>::type>
        -:   69:#define EIGEN_MATHFUNC_RETVAL(func, scalar) typename Eigen::internal::func##_retval<typename Eigen::internal::global_math_functions_filtering_base<scalar>::type>::type
        -:   70:
        -:   71:/****************************************************************************
        -:   72:* Implementation of real                                                 *
        -:   73:****************************************************************************/
        -:   74:
        -:   75:template<typename Scalar, bool IsComplex = NumTraits<Scalar>::IsComplex>
        -:   76:struct real_default_impl
        -:   77:{
        -:   78:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -:   79:  EIGEN_DEVICE_FUNC
        -:   80:  static inline RealScalar run(const Scalar& x)
        -:   81:  {
        -:   82:    return x;
        -:   83:  }
        -:   84:};
        -:   85:
        -:   86:template<typename Scalar>
        -:   87:struct real_default_impl<Scalar,true>
        -:   88:{
        -:   89:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -:   90:  EIGEN_DEVICE_FUNC
        -:   91:  static inline RealScalar run(const Scalar& x)
        -:   92:  {
        -:   93:    using std::real;
        -:   94:    return real(x);
        -:   95:  }
        -:   96:};
        -:   97:
        -:   98:template<typename Scalar> struct real_impl : real_default_impl<Scalar> {};
        -:   99:
        -:  100:#ifdef __CUDA_ARCH__
        -:  101:template<typename T>
        -:  102:struct real_impl<std::complex<T> >
        -:  103:{
        -:  104:  typedef T RealScalar;
        -:  105:  EIGEN_DEVICE_FUNC
        -:  106:  static inline T run(const std::complex<T>& x)
        -:  107:  {
        -:  108:    return x.real();
        -:  109:  }
        -:  110:};
        -:  111:#endif
        -:  112:
        -:  113:template<typename Scalar>
        -:  114:struct real_retval
        -:  115:{
        -:  116:  typedef typename NumTraits<Scalar>::Real type;
        -:  117:};
        -:  118:
        -:  119:/****************************************************************************
        -:  120:* Implementation of imag                                                 *
        -:  121:****************************************************************************/
        -:  122:
        -:  123:template<typename Scalar, bool IsComplex = NumTraits<Scalar>::IsComplex>
        -:  124:struct imag_default_impl
        -:  125:{
        -:  126:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -:  127:  EIGEN_DEVICE_FUNC
        -:  128:  static inline RealScalar run(const Scalar&)
        -:  129:  {
        -:  130:    return RealScalar(0);
        -:  131:  }
        -:  132:};
        -:  133:
        -:  134:template<typename Scalar>
        -:  135:struct imag_default_impl<Scalar,true>
        -:  136:{
        -:  137:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -:  138:  EIGEN_DEVICE_FUNC
        -:  139:  static inline RealScalar run(const Scalar& x)
        -:  140:  {
        -:  141:    using std::imag;
        -:  142:    return imag(x);
        -:  143:  }
        -:  144:};
        -:  145:
        -:  146:template<typename Scalar> struct imag_impl : imag_default_impl<Scalar> {};
        -:  147:
        -:  148:#ifdef __CUDA_ARCH__
        -:  149:template<typename T>
        -:  150:struct imag_impl<std::complex<T> >
        -:  151:{
        -:  152:  typedef T RealScalar;
        -:  153:  EIGEN_DEVICE_FUNC
        -:  154:  static inline T run(const std::complex<T>& x)
        -:  155:  {
        -:  156:    return x.imag();
        -:  157:  }
        -:  158:};
        -:  159:#endif
        -:  160:
        -:  161:template<typename Scalar>
        -:  162:struct imag_retval
        -:  163:{
        -:  164:  typedef typename NumTraits<Scalar>::Real type;
        -:  165:};
        -:  166:
        -:  167:/****************************************************************************
        -:  168:* Implementation of real_ref                                             *
        -:  169:****************************************************************************/
        -:  170:
        -:  171:template<typename Scalar>
        -:  172:struct real_ref_impl
        -:  173:{
        -:  174:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -:  175:  EIGEN_DEVICE_FUNC
        -:  176:  static inline RealScalar& run(Scalar& x)
        -:  177:  {
        -:  178:    return reinterpret_cast<RealScalar*>(&x)[0];
        -:  179:  }
        -:  180:  EIGEN_DEVICE_FUNC
        -:  181:  static inline const RealScalar& run(const Scalar& x)
        -:  182:  {
        -:  183:    return reinterpret_cast<const RealScalar*>(&x)[0];
        -:  184:  }
        -:  185:};
        -:  186:
        -:  187:template<typename Scalar>
        -:  188:struct real_ref_retval
        -:  189:{
        -:  190:  typedef typename NumTraits<Scalar>::Real & type;
        -:  191:};
        -:  192:
        -:  193:/****************************************************************************
        -:  194:* Implementation of imag_ref                                             *
        -:  195:****************************************************************************/
        -:  196:
        -:  197:template<typename Scalar, bool IsComplex>
        -:  198:struct imag_ref_default_impl
        -:  199:{
        -:  200:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -:  201:  EIGEN_DEVICE_FUNC
        -:  202:  static inline RealScalar& run(Scalar& x)
        -:  203:  {
        -:  204:    return reinterpret_cast<RealScalar*>(&x)[1];
        -:  205:  }
        -:  206:  EIGEN_DEVICE_FUNC
        -:  207:  static inline const RealScalar& run(const Scalar& x)
        -:  208:  {
        -:  209:    return reinterpret_cast<RealScalar*>(&x)[1];
        -:  210:  }
        -:  211:};
        -:  212:
        -:  213:template<typename Scalar>
        -:  214:struct imag_ref_default_impl<Scalar, false>
        -:  215:{
        -:  216:  EIGEN_DEVICE_FUNC
        -:  217:  static inline Scalar run(Scalar&)
        -:  218:  {
        -:  219:    return Scalar(0);
        -:  220:  }
        -:  221:  EIGEN_DEVICE_FUNC
        -:  222:  static inline const Scalar run(const Scalar&)
        -:  223:  {
        -:  224:    return Scalar(0);
        -:  225:  }
        -:  226:};
        -:  227:
        -:  228:template<typename Scalar>
        -:  229:struct imag_ref_impl : imag_ref_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};
        -:  230:
        -:  231:template<typename Scalar>
        -:  232:struct imag_ref_retval
        -:  233:{
        -:  234:  typedef typename NumTraits<Scalar>::Real & type;
        -:  235:};
        -:  236:
        -:  237:/****************************************************************************
        -:  238:* Implementation of conj                                                 *
        -:  239:****************************************************************************/
        -:  240:
        -:  241:template<typename Scalar, bool IsComplex = NumTraits<Scalar>::IsComplex>
        -:  242:struct conj_impl
        -:  243:{
        -:  244:  EIGEN_DEVICE_FUNC
        -:  245:  static inline Scalar run(const Scalar& x)
        -:  246:  {
        -:  247:    return x;
        -:  248:  }
        -:  249:};
        -:  250:
        -:  251:template<typename Scalar>
        -:  252:struct conj_impl<Scalar,true>
        -:  253:{
        -:  254:  EIGEN_DEVICE_FUNC
        -:  255:  static inline Scalar run(const Scalar& x)
        -:  256:  {
        -:  257:    using std::conj;
        -:  258:    return conj(x);
        -:  259:  }
        -:  260:};
        -:  261:
        -:  262:template<typename Scalar>
        -:  263:struct conj_retval
        -:  264:{
        -:  265:  typedef Scalar type;
        -:  266:};
        -:  267:
        -:  268:/****************************************************************************
        -:  269:* Implementation of abs2                                                 *
        -:  270:****************************************************************************/
        -:  271:
        -:  272:template<typename Scalar,bool IsComplex>
        -:  273:struct abs2_impl_default
        -:  274:{
        -:  275:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -:  276:  EIGEN_DEVICE_FUNC
    #####:  277:  static inline RealScalar run(const Scalar& x)
        -:  278:  {
    #####:  279:    return x*x;
        -:  280:  }
        -:  281:};
        -:  282:
        -:  283:template<typename Scalar>
        -:  284:struct abs2_impl_default<Scalar, true> // IsComplex
        -:  285:{
        -:  286:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -:  287:  EIGEN_DEVICE_FUNC
        -:  288:  static inline RealScalar run(const Scalar& x)
        -:  289:  {
        -:  290:    return real(x)*real(x) + imag(x)*imag(x);
        -:  291:  }
        -:  292:};
        -:  293:
        -:  294:template<typename Scalar>
        -:  295:struct abs2_impl
        -:  296:{
        -:  297:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -:  298:  EIGEN_DEVICE_FUNC
    #####:  299:  static inline RealScalar run(const Scalar& x)
        -:  300:  {
    #####:  301:    return abs2_impl_default<Scalar,NumTraits<Scalar>::IsComplex>::run(x);
        -:  302:  }
        -:  303:};
        -:  304:
        -:  305:template<typename Scalar>
        -:  306:struct abs2_retval
        -:  307:{
        -:  308:  typedef typename NumTraits<Scalar>::Real type;
        -:  309:};
        -:  310:
        -:  311:/****************************************************************************
        -:  312:* Implementation of norm1                                                *
        -:  313:****************************************************************************/
        -:  314:
        -:  315:template<typename Scalar, bool IsComplex>
        -:  316:struct norm1_default_impl
        -:  317:{
        -:  318:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -:  319:  EIGEN_DEVICE_FUNC
        -:  320:  static inline RealScalar run(const Scalar& x)
        -:  321:  {
        -:  322:    EIGEN_USING_STD_MATH(abs);
        -:  323:    return abs(real(x)) + abs(imag(x));
        -:  324:  }
        -:  325:};
        -:  326:
        -:  327:template<typename Scalar>
        -:  328:struct norm1_default_impl<Scalar, false>
        -:  329:{
        -:  330:  EIGEN_DEVICE_FUNC
        -:  331:  static inline Scalar run(const Scalar& x)
        -:  332:  {
        -:  333:    EIGEN_USING_STD_MATH(abs);
        -:  334:    return abs(x);
        -:  335:  }
        -:  336:};
        -:  337:
        -:  338:template<typename Scalar>
        -:  339:struct norm1_impl : norm1_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};
        -:  340:
        -:  341:template<typename Scalar>
        -:  342:struct norm1_retval
        -:  343:{
        -:  344:  typedef typename NumTraits<Scalar>::Real type;
        -:  345:};
        -:  346:
        -:  347:/****************************************************************************
        -:  348:* Implementation of hypot                                                *
        -:  349:****************************************************************************/
        -:  350:
        -:  351:template<typename Scalar>
        -:  352:struct hypot_impl
        -:  353:{
        -:  354:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -:  355:  static inline RealScalar run(const Scalar& x, const Scalar& y)
        -:  356:  {
        -:  357:    EIGEN_USING_STD_MATH(abs);
        -:  358:    EIGEN_USING_STD_MATH(sqrt);
        -:  359:    RealScalar _x = abs(x);
        -:  360:    RealScalar _y = abs(y);
        -:  361:    Scalar p, qp;
        -:  362:    if(_x>_y)
        -:  363:    {
        -:  364:      p = _x;
        -:  365:      qp = _y / p;
        -:  366:    }
        -:  367:    else
        -:  368:    {
        -:  369:      p = _y;
        -:  370:      qp = _x / p;
        -:  371:    }
        -:  372:    if(p==RealScalar(0)) return RealScalar(0);
        -:  373:    return p * sqrt(RealScalar(1) + qp*qp);
        -:  374:  }
        -:  375:};
        -:  376:
        -:  377:template<typename Scalar>
        -:  378:struct hypot_retval
        -:  379:{
        -:  380:  typedef typename NumTraits<Scalar>::Real type;
        -:  381:};
        -:  382:
        -:  383:/****************************************************************************
        -:  384:* Implementation of cast                                                 *
        -:  385:****************************************************************************/
        -:  386:
        -:  387:template<typename OldType, typename NewType>
        -:  388:struct cast_impl
        -:  389:{
        -:  390:  EIGEN_DEVICE_FUNC
        -:  391:  static inline NewType run(const OldType& x)
        -:  392:  {
        -:  393:    return static_cast<NewType>(x);
        -:  394:  }
        -:  395:};
        -:  396:
        -:  397:// here, for once, we're plainly returning NewType: we don't want cast to do weird things.
        -:  398:
        -:  399:template<typename OldType, typename NewType>
        -:  400:EIGEN_DEVICE_FUNC
        -:  401:inline NewType cast(const OldType& x)
        -:  402:{
        -:  403:  return cast_impl<OldType, NewType>::run(x);
        -:  404:}
        -:  405:
        -:  406:/****************************************************************************
        -:  407:* Implementation of round                                                   *
        -:  408:****************************************************************************/
        -:  409:
        -:  410:#if EIGEN_HAS_CXX11_MATH
        -:  411:  template<typename Scalar>
        -:  412:  struct round_impl {
        -:  413:    static inline Scalar run(const Scalar& x)
        -:  414:    {
        -:  415:      EIGEN_STATIC_ASSERT((!NumTraits<Scalar>::IsComplex), NUMERIC_TYPE_MUST_BE_REAL)
        -:  416:      using std::round;
        -:  417:      return round(x);
        -:  418:    }
        -:  419:  };
        -:  420:#else
        -:  421:  template<typename Scalar>
        -:  422:  struct round_impl
        -:  423:  {
        -:  424:    static inline Scalar run(const Scalar& x)
        -:  425:    {
        -:  426:      EIGEN_STATIC_ASSERT((!NumTraits<Scalar>::IsComplex), NUMERIC_TYPE_MUST_BE_REAL)
        -:  427:      EIGEN_USING_STD_MATH(floor);
        -:  428:      EIGEN_USING_STD_MATH(ceil);
        -:  429:      return (x > Scalar(0)) ? floor(x + Scalar(0.5)) : ceil(x - Scalar(0.5));
        -:  430:    }
        -:  431:  };
        -:  432:#endif
        -:  433:
        -:  434:template<typename Scalar>
        -:  435:struct round_retval
        -:  436:{
        -:  437:  typedef Scalar type;
        -:  438:};
        -:  439:
        -:  440:/****************************************************************************
        -:  441:* Implementation of arg                                                     *
        -:  442:****************************************************************************/
        -:  443:
        -:  444:#if EIGEN_HAS_CXX11_MATH
        -:  445:  template<typename Scalar>
        -:  446:  struct arg_impl {
        -:  447:    static inline Scalar run(const Scalar& x)
        -:  448:    {
        -:  449:      EIGEN_USING_STD_MATH(arg);
        -:  450:      return arg(x);
        -:  451:    }
        -:  452:  };
        -:  453:#else
        -:  454:  template<typename Scalar, bool IsComplex = NumTraits<Scalar>::IsComplex>
        -:  455:  struct arg_default_impl
        -:  456:  {
        -:  457:    typedef typename NumTraits<Scalar>::Real RealScalar;
        -:  458:    EIGEN_DEVICE_FUNC
        -:  459:    static inline RealScalar run(const Scalar& x)
        -:  460:    {
        -:  461:      return (x < Scalar(0)) ? Scalar(EIGEN_PI) : Scalar(0); }
        -:  462:  };
        -:  463:
        -:  464:  template<typename Scalar>
        -:  465:  struct arg_default_impl<Scalar,true>
        -:  466:  {
        -:  467:    typedef typename NumTraits<Scalar>::Real RealScalar;
        -:  468:    EIGEN_DEVICE_FUNC
        -:  469:    static inline RealScalar run(const Scalar& x)
        -:  470:    {
        -:  471:      EIGEN_USING_STD_MATH(arg);
        -:  472:      return arg(x);
        -:  473:    }
        -:  474:  };
        -:  475:
        -:  476:  template<typename Scalar> struct arg_impl : arg_default_impl<Scalar> {};
        -:  477:#endif
        -:  478:
        -:  479:template<typename Scalar>
        -:  480:struct arg_retval
        -:  481:{
        -:  482:  typedef typename NumTraits<Scalar>::Real type;
        -:  483:};
        -:  484:
        -:  485:/****************************************************************************
        -:  486:* Implementation of log1p                                                   *
        -:  487:****************************************************************************/
        -:  488:
        -:  489:namespace std_fallback {
        -:  490:  // fallback log1p implementation in case there is no log1p(Scalar) function in namespace of Scalar,
        -:  491:  // or that there is no suitable std::log1p function available
        -:  492:  template<typename Scalar>
        -:  493:  EIGEN_DEVICE_FUNC inline Scalar log1p(const Scalar& x) {
        -:  494:    EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)
        -:  495:    typedef typename NumTraits<Scalar>::Real RealScalar;
        -:  496:    EIGEN_USING_STD_MATH(log);
        -:  497:    Scalar x1p = RealScalar(1) + x;
        -:  498:    return ( x1p == Scalar(1) ) ? x : x * ( log(x1p) / (x1p - RealScalar(1)) );
        -:  499:  }
        -:  500:}
        -:  501:
        -:  502:template<typename Scalar>
        -:  503:struct log1p_impl {
        -:  504:  static inline Scalar run(const Scalar& x)
        -:  505:  {
        -:  506:    EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)
        -:  507:    #if EIGEN_HAS_CXX11_MATH
        -:  508:    using std::log1p;
        -:  509:    #endif
        -:  510:    using std_fallback::log1p;
        -:  511:    return log1p(x);
        -:  512:  }
        -:  513:};
        -:  514:
        -:  515:
        -:  516:template<typename Scalar>
        -:  517:struct log1p_retval
        -:  518:{
        -:  519:  typedef Scalar type;
        -:  520:};
        -:  521:
        -:  522:/****************************************************************************
        -:  523:* Implementation of pow                                                  *
        -:  524:****************************************************************************/
        -:  525:
        -:  526:template<typename ScalarX,typename ScalarY, bool IsInteger = NumTraits<ScalarX>::IsInteger&&NumTraits<ScalarY>::IsInteger>
        -:  527:struct pow_impl
        -:  528:{
        -:  529:  //typedef Scalar retval;
        -:  530:  typedef typename ScalarBinaryOpTraits<ScalarX,ScalarY,internal::scalar_pow_op<ScalarX,ScalarY> >::ReturnType result_type;
        -:  531:  static EIGEN_DEVICE_FUNC inline result_type run(const ScalarX& x, const ScalarY& y)
        -:  532:  {
        -:  533:    EIGEN_USING_STD_MATH(pow);
        -:  534:    return pow(x, y);
        -:  535:  }
        -:  536:};
        -:  537:
        -:  538:template<typename ScalarX,typename ScalarY>
        -:  539:struct pow_impl<ScalarX,ScalarY, true>
        -:  540:{
        -:  541:  typedef ScalarX result_type;
        -:  542:  static EIGEN_DEVICE_FUNC inline ScalarX run(ScalarX x, ScalarY y)
        -:  543:  {
        -:  544:    ScalarX res(1);
        -:  545:    eigen_assert(!NumTraits<ScalarY>::IsSigned || y >= 0);
        -:  546:    if(y & 1) res *= x;
        -:  547:    y >>= 1;
        -:  548:    while(y)
        -:  549:    {
        -:  550:      x *= x;
        -:  551:      if(y&1) res *= x;
        -:  552:      y >>= 1;
        -:  553:    }
        -:  554:    return res;
        -:  555:  }
        -:  556:};
        -:  557:
        -:  558:/****************************************************************************
        -:  559:* Implementation of random                                               *
        -:  560:****************************************************************************/
        -:  561:
        -:  562:template<typename Scalar,
        -:  563:         bool IsComplex,
        -:  564:         bool IsInteger>
        -:  565:struct random_default_impl {};
        -:  566:
        -:  567:template<typename Scalar>
        -:  568:struct random_impl : random_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};
        -:  569:
        -:  570:template<typename Scalar>
        -:  571:struct random_retval
        -:  572:{
        -:  573:  typedef Scalar type;
        -:  574:};
        -:  575:
        -:  576:template<typename Scalar> inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y);
        -:  577:template<typename Scalar> inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random();
        -:  578:
        -:  579:template<typename Scalar>
        -:  580:struct random_default_impl<Scalar, false, false>
        -:  581:{
        -:  582:  static inline Scalar run(const Scalar& x, const Scalar& y)
        -:  583:  {
        -:  584:    return x + (y-x) * Scalar(std::rand()) / Scalar(RAND_MAX);
        -:  585:  }
        -:  586:  static inline Scalar run()
        -:  587:  {
        -:  588:    return run(Scalar(NumTraits<Scalar>::IsSigned ? -1 : 0), Scalar(1));
        -:  589:  }
        -:  590:};
        -:  591:
        -:  592:enum {
        -:  593:  meta_floor_log2_terminate,
        -:  594:  meta_floor_log2_move_up,
        -:  595:  meta_floor_log2_move_down,
        -:  596:  meta_floor_log2_bogus
        -:  597:};
        -:  598:
        -:  599:template<unsigned int n, int lower, int upper> struct meta_floor_log2_selector
        -:  600:{
        -:  601:  enum { middle = (lower + upper) / 2,
        -:  602:         value = (upper <= lower + 1) ? int(meta_floor_log2_terminate)
        -:  603:               : (n < (1 << middle)) ? int(meta_floor_log2_move_down)
        -:  604:               : (n==0) ? int(meta_floor_log2_bogus)
        -:  605:               : int(meta_floor_log2_move_up)
        -:  606:  };
        -:  607:};
        -:  608:
        -:  609:template<unsigned int n,
        -:  610:         int lower = 0,
        -:  611:         int upper = sizeof(unsigned int) * CHAR_BIT - 1,
        -:  612:         int selector = meta_floor_log2_selector<n, lower, upper>::value>
        -:  613:struct meta_floor_log2 {};
        -:  614:
        -:  615:template<unsigned int n, int lower, int upper>
        -:  616:struct meta_floor_log2<n, lower, upper, meta_floor_log2_move_down>
        -:  617:{
        -:  618:  enum { value = meta_floor_log2<n, lower, meta_floor_log2_selector<n, lower, upper>::middle>::value };
        -:  619:};
        -:  620:
        -:  621:template<unsigned int n, int lower, int upper>
        -:  622:struct meta_floor_log2<n, lower, upper, meta_floor_log2_move_up>
        -:  623:{
        -:  624:  enum { value = meta_floor_log2<n, meta_floor_log2_selector<n, lower, upper>::middle, upper>::value };
        -:  625:};
        -:  626:
        -:  627:template<unsigned int n, int lower, int upper>
        -:  628:struct meta_floor_log2<n, lower, upper, meta_floor_log2_terminate>
        -:  629:{
        -:  630:  enum { value = (n >= ((unsigned int)(1) << (lower+1))) ? lower+1 : lower };
        -:  631:};
        -:  632:
        -:  633:template<unsigned int n, int lower, int upper>
        -:  634:struct meta_floor_log2<n, lower, upper, meta_floor_log2_bogus>
        -:  635:{
        -:  636:  // no value, error at compile time
        -:  637:};
        -:  638:
        -:  639:template<typename Scalar>
        -:  640:struct random_default_impl<Scalar, false, true>
        -:  641:{
        -:  642:  static inline Scalar run(const Scalar& x, const Scalar& y)
        -:  643:  { 
        -:  644:    typedef typename conditional<NumTraits<Scalar>::IsSigned,std::ptrdiff_t,std::size_t>::type ScalarX;
        -:  645:    if(y<x)
        -:  646:      return x;
        -:  647:    // the following difference might overflow on a 32 bits system,
        -:  648:    // but since y>=x the result converted to an unsigned long is still correct.
        -:  649:    std::size_t range = ScalarX(y)-ScalarX(x);
        -:  650:    std::size_t offset = 0;
        -:  651:    // rejection sampling
        -:  652:    std::size_t divisor = 1;
        -:  653:    std::size_t multiplier = 1;
        -:  654:    if(range<RAND_MAX) divisor = (std::size_t(RAND_MAX)+1)/(range+1);
        -:  655:    else               multiplier = 1 + range/(std::size_t(RAND_MAX)+1);
        -:  656:    do {
        -:  657:      offset = (std::size_t(std::rand()) * multiplier) / divisor;
        -:  658:    } while (offset > range);
        -:  659:    return Scalar(ScalarX(x) + offset);
        -:  660:  }
        -:  661:
        -:  662:  static inline Scalar run()
        -:  663:  {
        -:  664:#ifdef EIGEN_MAKING_DOCS
        -:  665:    return run(Scalar(NumTraits<Scalar>::IsSigned ? -10 : 0), Scalar(10));
        -:  666:#else
        -:  667:    enum { rand_bits = meta_floor_log2<(unsigned int)(RAND_MAX)+1>::value,
        -:  668:           scalar_bits = sizeof(Scalar) * CHAR_BIT,
        -:  669:           shift = EIGEN_PLAIN_ENUM_MAX(0, int(rand_bits) - int(scalar_bits)),
        -:  670:           offset = NumTraits<Scalar>::IsSigned ? (1 << (EIGEN_PLAIN_ENUM_MIN(rand_bits,scalar_bits)-1)) : 0
        -:  671:    };
        -:  672:    return Scalar((std::rand() >> shift) - offset);
        -:  673:#endif
        -:  674:  }
        -:  675:};
        -:  676:
        -:  677:template<typename Scalar>
        -:  678:struct random_default_impl<Scalar, true, false>
        -:  679:{
        -:  680:  static inline Scalar run(const Scalar& x, const Scalar& y)
        -:  681:  {
        -:  682:    return Scalar(random(real(x), real(y)),
        -:  683:                  random(imag(x), imag(y)));
        -:  684:  }
        -:  685:  static inline Scalar run()
        -:  686:  {
        -:  687:    typedef typename NumTraits<Scalar>::Real RealScalar;
        -:  688:    return Scalar(random<RealScalar>(), random<RealScalar>());
        -:  689:  }
        -:  690:};
        -:  691:
        -:  692:template<typename Scalar>
        -:  693:inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y)
        -:  694:{
        -:  695:  return EIGEN_MATHFUNC_IMPL(random, Scalar)::run(x, y);
        -:  696:}
        -:  697:
        -:  698:template<typename Scalar>
        -:  699:inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random()
        -:  700:{
        -:  701:  return EIGEN_MATHFUNC_IMPL(random, Scalar)::run();
        -:  702:}
        -:  703:
        -:  704:// Implementatin of is* functions
        -:  705:
        -:  706:// std::is* do not work with fast-math and gcc, std::is* are available on MSVC 2013 and newer, as well as in clang.
        -:  707:#if (EIGEN_HAS_CXX11_MATH && !(EIGEN_COMP_GNUC_STRICT && __FINITE_MATH_ONLY__)) || (EIGEN_COMP_MSVC>=1800) || (EIGEN_COMP_CLANG)
        -:  708:#define EIGEN_USE_STD_FPCLASSIFY 1
        -:  709:#else
        -:  710:#define EIGEN_USE_STD_FPCLASSIFY 0
        -:  711:#endif
        -:  712:
        -:  713:template<typename T>
        -:  714:EIGEN_DEVICE_FUNC
        -:  715:typename internal::enable_if<internal::is_integral<T>::value,bool>::type
        -:  716:isnan_impl(const T&) { return false; }
        -:  717:
        -:  718:template<typename T>
        -:  719:EIGEN_DEVICE_FUNC
        -:  720:typename internal::enable_if<internal::is_integral<T>::value,bool>::type
        -:  721:isinf_impl(const T&) { return false; }
        -:  722:
        -:  723:template<typename T>
        -:  724:EIGEN_DEVICE_FUNC
        -:  725:typename internal::enable_if<internal::is_integral<T>::value,bool>::type
        -:  726:isfinite_impl(const T&) { return true; }
        -:  727:
        -:  728:template<typename T>
        -:  729:EIGEN_DEVICE_FUNC
        -:  730:typename internal::enable_if<(!internal::is_integral<T>::value)&&(!NumTraits<T>::IsComplex),bool>::type
        -:  731:isfinite_impl(const T& x)
        -:  732:{
        -:  733:  #ifdef __CUDA_ARCH__
        -:  734:    return (::isfinite)(x);
        -:  735:  #elif EIGEN_USE_STD_FPCLASSIFY
        -:  736:    using std::isfinite;
        -:  737:    return isfinite EIGEN_NOT_A_MACRO (x);
        -:  738:  #else
        -:  739:    return x<=NumTraits<T>::highest() && x>=NumTraits<T>::lowest();
        -:  740:  #endif
        -:  741:}
        -:  742:
        -:  743:template<typename T>
        -:  744:EIGEN_DEVICE_FUNC
        -:  745:typename internal::enable_if<(!internal::is_integral<T>::value)&&(!NumTraits<T>::IsComplex),bool>::type
        -:  746:isinf_impl(const T& x)
        -:  747:{
        -:  748:  #ifdef __CUDA_ARCH__
        -:  749:    return (::isinf)(x);
        -:  750:  #elif EIGEN_USE_STD_FPCLASSIFY
        -:  751:    using std::isinf;
        -:  752:    return isinf EIGEN_NOT_A_MACRO (x);
        -:  753:  #else
        -:  754:    return x>NumTraits<T>::highest() || x<NumTraits<T>::lowest();
        -:  755:  #endif
        -:  756:}
        -:  757:
        -:  758:template<typename T>
        -:  759:EIGEN_DEVICE_FUNC
        -:  760:typename internal::enable_if<(!internal::is_integral<T>::value)&&(!NumTraits<T>::IsComplex),bool>::type
        -:  761:isnan_impl(const T& x)
        -:  762:{
        -:  763:  #ifdef __CUDA_ARCH__
        -:  764:    return (::isnan)(x);
        -:  765:  #elif EIGEN_USE_STD_FPCLASSIFY
        -:  766:    using std::isnan;
        -:  767:    return isnan EIGEN_NOT_A_MACRO (x);
        -:  768:  #else
        -:  769:    return x != x;
        -:  770:  #endif
        -:  771:}
        -:  772:
        -:  773:#if (!EIGEN_USE_STD_FPCLASSIFY)
        -:  774:
        -:  775:#if EIGEN_COMP_MSVC
        -:  776:
        -:  777:template<typename T> EIGEN_DEVICE_FUNC bool isinf_msvc_helper(T x)
        -:  778:{
        -:  779:  return _fpclass(x)==_FPCLASS_NINF || _fpclass(x)==_FPCLASS_PINF;
        -:  780:}
        -:  781:
        -:  782://MSVC defines a _isnan builtin function, but for double only
        -:  783:EIGEN_DEVICE_FUNC inline bool isnan_impl(const long double& x) { return _isnan(x)!=0; }
        -:  784:EIGEN_DEVICE_FUNC inline bool isnan_impl(const double& x)      { return _isnan(x)!=0; }
        -:  785:EIGEN_DEVICE_FUNC inline bool isnan_impl(const float& x)       { return _isnan(x)!=0; }
        -:  786:
        -:  787:EIGEN_DEVICE_FUNC inline bool isinf_impl(const long double& x) { return isinf_msvc_helper(x); }
        -:  788:EIGEN_DEVICE_FUNC inline bool isinf_impl(const double& x)      { return isinf_msvc_helper(x); }
        -:  789:EIGEN_DEVICE_FUNC inline bool isinf_impl(const float& x)       { return isinf_msvc_helper(x); }
        -:  790:
        -:  791:#elif (defined __FINITE_MATH_ONLY__ && __FINITE_MATH_ONLY__ && EIGEN_COMP_GNUC)
        -:  792:
        -:  793:#if EIGEN_GNUC_AT_LEAST(5,0)
        -:  794:  #define EIGEN_TMP_NOOPT_ATTRIB EIGEN_DEVICE_FUNC inline __attribute__((optimize("no-finite-math-only")))
        -:  795:#else
        -:  796:  // NOTE the inline qualifier and noinline attribute are both needed: the former is to avoid linking issue (duplicate symbol),
        -:  797:  //      while the second prevent too aggressive optimizations in fast-math mode:
        -:  798:  #define EIGEN_TMP_NOOPT_ATTRIB EIGEN_DEVICE_FUNC inline __attribute__((noinline,optimize("no-finite-math-only")))
        -:  799:#endif
        -:  800:
        -:  801:template<> EIGEN_TMP_NOOPT_ATTRIB bool isnan_impl(const long double& x) { return __builtin_isnan(x); }
        -:  802:template<> EIGEN_TMP_NOOPT_ATTRIB bool isnan_impl(const double& x)      { return __builtin_isnan(x); }
        -:  803:template<> EIGEN_TMP_NOOPT_ATTRIB bool isnan_impl(const float& x)       { return __builtin_isnan(x); }
        -:  804:template<> EIGEN_TMP_NOOPT_ATTRIB bool isinf_impl(const double& x)      { return __builtin_isinf(x); }
        -:  805:template<> EIGEN_TMP_NOOPT_ATTRIB bool isinf_impl(const float& x)       { return __builtin_isinf(x); }
        -:  806:template<> EIGEN_TMP_NOOPT_ATTRIB bool isinf_impl(const long double& x) { return __builtin_isinf(x); }
        -:  807:
        -:  808:#undef EIGEN_TMP_NOOPT_ATTRIB
        -:  809:
        -:  810:#endif
        -:  811:
        -:  812:#endif
        -:  813:
        -:  814:// The following overload are defined at the end of this file
        -:  815:template<typename T> EIGEN_DEVICE_FUNC bool isfinite_impl(const std::complex<T>& x);
        -:  816:template<typename T> EIGEN_DEVICE_FUNC bool isnan_impl(const std::complex<T>& x);
        -:  817:template<typename T> EIGEN_DEVICE_FUNC bool isinf_impl(const std::complex<T>& x);
        -:  818:
        -:  819:template<typename T> T generic_fast_tanh_float(const T& a_x);
        -:  820:
        -:  821:} // end namespace internal
        -:  822:
        -:  823:/****************************************************************************
        -:  824:* Generic math functions                                                    *
        -:  825:****************************************************************************/
        -:  826:
        -:  827:namespace numext {
        -:  828:
        -:  829:#ifndef __CUDA_ARCH__
        -:  830:template<typename T>
        -:  831:EIGEN_DEVICE_FUNC
        -:  832:EIGEN_ALWAYS_INLINE T mini(const T& x, const T& y)
        -:  833:{
        -:  834:  EIGEN_USING_STD_MATH(min);
    #####:  835:  return min EIGEN_NOT_A_MACRO (x,y);
        -:  836:}
        -:  837:
        -:  838:template<typename T>
        -:  839:EIGEN_DEVICE_FUNC
        -:  840:EIGEN_ALWAYS_INLINE T maxi(const T& x, const T& y)
        -:  841:{
        -:  842:  EIGEN_USING_STD_MATH(max);
    #####:  843:  return max EIGEN_NOT_A_MACRO (x,y);
        -:  844:}
        -:  845:#else
        -:  846:template<typename T>
        -:  847:EIGEN_DEVICE_FUNC
        -:  848:EIGEN_ALWAYS_INLINE T mini(const T& x, const T& y)
        -:  849:{
        -:  850:  return y < x ? y : x;
        -:  851:}
        -:  852:template<>
        -:  853:EIGEN_DEVICE_FUNC
        -:  854:EIGEN_ALWAYS_INLINE float mini(const float& x, const float& y)
        -:  855:{
        -:  856:  return fminf(x, y);
        -:  857:}
        -:  858:template<typename T>
        -:  859:EIGEN_DEVICE_FUNC
        -:  860:EIGEN_ALWAYS_INLINE T maxi(const T& x, const T& y)
        -:  861:{
        -:  862:  return x < y ? y : x;
        -:  863:}
        -:  864:template<>
        -:  865:EIGEN_DEVICE_FUNC
        -:  866:EIGEN_ALWAYS_INLINE float maxi(const float& x, const float& y)
        -:  867:{
        -:  868:  return fmaxf(x, y);
        -:  869:}
        -:  870:#endif
        -:  871:
        -:  872:
        -:  873:template<typename Scalar>
        -:  874:EIGEN_DEVICE_FUNC
        -:  875:inline EIGEN_MATHFUNC_RETVAL(real, Scalar) real(const Scalar& x)
        -:  876:{
        -:  877:  return EIGEN_MATHFUNC_IMPL(real, Scalar)::run(x);
        -:  878:}
        -:  879:
        -:  880:template<typename Scalar>
        -:  881:EIGEN_DEVICE_FUNC
        -:  882:inline typename internal::add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) >::type real_ref(const Scalar& x)
        -:  883:{
        -:  884:  return internal::real_ref_impl<Scalar>::run(x);
        -:  885:}
        -:  886:
        -:  887:template<typename Scalar>
        -:  888:EIGEN_DEVICE_FUNC
        -:  889:inline EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) real_ref(Scalar& x)
        -:  890:{
        -:  891:  return EIGEN_MATHFUNC_IMPL(real_ref, Scalar)::run(x);
        -:  892:}
        -:  893:
        -:  894:template<typename Scalar>
        -:  895:EIGEN_DEVICE_FUNC
        -:  896:inline EIGEN_MATHFUNC_RETVAL(imag, Scalar) imag(const Scalar& x)
        -:  897:{
        -:  898:  return EIGEN_MATHFUNC_IMPL(imag, Scalar)::run(x);
        -:  899:}
        -:  900:
        -:  901:template<typename Scalar>
        -:  902:EIGEN_DEVICE_FUNC
        -:  903:inline EIGEN_MATHFUNC_RETVAL(arg, Scalar) arg(const Scalar& x)
        -:  904:{
        -:  905:  return EIGEN_MATHFUNC_IMPL(arg, Scalar)::run(x);
        -:  906:}
        -:  907:
        -:  908:template<typename Scalar>
        -:  909:EIGEN_DEVICE_FUNC
        -:  910:inline typename internal::add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) >::type imag_ref(const Scalar& x)
        -:  911:{
        -:  912:  return internal::imag_ref_impl<Scalar>::run(x);
        -:  913:}
        -:  914:
        -:  915:template<typename Scalar>
        -:  916:EIGEN_DEVICE_FUNC
        -:  917:inline EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) imag_ref(Scalar& x)
        -:  918:{
        -:  919:  return EIGEN_MATHFUNC_IMPL(imag_ref, Scalar)::run(x);
        -:  920:}
        -:  921:
        -:  922:template<typename Scalar>
        -:  923:EIGEN_DEVICE_FUNC
        -:  924:inline EIGEN_MATHFUNC_RETVAL(conj, Scalar) conj(const Scalar& x)
        -:  925:{
        -:  926:  return EIGEN_MATHFUNC_IMPL(conj, Scalar)::run(x);
        -:  927:}
        -:  928:
        -:  929:template<typename Scalar>
        -:  930:EIGEN_DEVICE_FUNC
    #####:  931:inline EIGEN_MATHFUNC_RETVAL(abs2, Scalar) abs2(const Scalar& x)
        -:  932:{
    #####:  933:  return EIGEN_MATHFUNC_IMPL(abs2, Scalar)::run(x);
        -:  934:}
        -:  935:
        -:  936:template<typename Scalar>
        -:  937:EIGEN_DEVICE_FUNC
        -:  938:inline EIGEN_MATHFUNC_RETVAL(norm1, Scalar) norm1(const Scalar& x)
        -:  939:{
        -:  940:  return EIGEN_MATHFUNC_IMPL(norm1, Scalar)::run(x);
        -:  941:}
        -:  942:
        -:  943:template<typename Scalar>
        -:  944:EIGEN_DEVICE_FUNC
        -:  945:inline EIGEN_MATHFUNC_RETVAL(hypot, Scalar) hypot(const Scalar& x, const Scalar& y)
        -:  946:{
        -:  947:  return EIGEN_MATHFUNC_IMPL(hypot, Scalar)::run(x, y);
        -:  948:}
        -:  949:
        -:  950:template<typename Scalar>
        -:  951:EIGEN_DEVICE_FUNC
        -:  952:inline EIGEN_MATHFUNC_RETVAL(log1p, Scalar) log1p(const Scalar& x)
        -:  953:{
        -:  954:  return EIGEN_MATHFUNC_IMPL(log1p, Scalar)::run(x);
        -:  955:}
        -:  956:
        -:  957:#ifdef __CUDACC__
        -:  958:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -:  959:float log1p(const float &x) { return ::log1pf(x); }
        -:  960:
        -:  961:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -:  962:double log1p(const double &x) { return ::log1p(x); }
        -:  963:#endif
        -:  964:
        -:  965:template<typename ScalarX,typename ScalarY>
        -:  966:EIGEN_DEVICE_FUNC
        -:  967:inline typename internal::pow_impl<ScalarX,ScalarY>::result_type pow(const ScalarX& x, const ScalarY& y)
        -:  968:{
        -:  969:  return internal::pow_impl<ScalarX,ScalarY>::run(x, y);
        -:  970:}
        -:  971:
        -:  972:template<typename T> EIGEN_DEVICE_FUNC bool (isnan)   (const T &x) { return internal::isnan_impl(x); }
        -:  973:template<typename T> EIGEN_DEVICE_FUNC bool (isinf)   (const T &x) { return internal::isinf_impl(x); }
        -:  974:template<typename T> EIGEN_DEVICE_FUNC bool (isfinite)(const T &x) { return internal::isfinite_impl(x); }
        -:  975:
        -:  976:template<typename Scalar>
        -:  977:EIGEN_DEVICE_FUNC
        -:  978:inline EIGEN_MATHFUNC_RETVAL(round, Scalar) round(const Scalar& x)
        -:  979:{
        -:  980:  return EIGEN_MATHFUNC_IMPL(round, Scalar)::run(x);
        -:  981:}
        -:  982:
        -:  983:template<typename T>
        -:  984:EIGEN_DEVICE_FUNC
        -:  985:T (floor)(const T& x)
        -:  986:{
        -:  987:  EIGEN_USING_STD_MATH(floor);
        -:  988:  return floor(x);
        -:  989:}
        -:  990:
        -:  991:#ifdef __CUDACC__
        -:  992:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -:  993:float floor(const float &x) { return ::floorf(x); }
        -:  994:
        -:  995:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -:  996:double floor(const double &x) { return ::floor(x); }
        -:  997:#endif
        -:  998:
        -:  999:template<typename T>
        -: 1000:EIGEN_DEVICE_FUNC
        -: 1001:T (ceil)(const T& x)
        -: 1002:{
        -: 1003:  EIGEN_USING_STD_MATH(ceil);
        -: 1004:  return ceil(x);
        -: 1005:}
        -: 1006:
        -: 1007:#ifdef __CUDACC__
        -: 1008:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1009:float ceil(const float &x) { return ::ceilf(x); }
        -: 1010:
        -: 1011:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1012:double ceil(const double &x) { return ::ceil(x); }
        -: 1013:#endif
        -: 1014:
        -: 1015:
        -: 1016:/** Log base 2 for 32 bits positive integers.
        -: 1017:  * Conveniently returns 0 for x==0. */
        -: 1018:inline int log2(int x)
        -: 1019:{
        -: 1020:  eigen_assert(x>=0);
        -: 1021:  unsigned int v(x);
        -: 1022:  static const int table[32] = { 0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31 };
        -: 1023:  v |= v >> 1;
        -: 1024:  v |= v >> 2;
        -: 1025:  v |= v >> 4;
        -: 1026:  v |= v >> 8;
        -: 1027:  v |= v >> 16;
        -: 1028:  return table[(v * 0x07C4ACDDU) >> 27];
        -: 1029:}
        -: 1030:
        -: 1031:/** \returns the square root of \a x.
        -: 1032:  *
        -: 1033:  * It is essentially equivalent to \code using std::sqrt; return sqrt(x); \endcode,
        -: 1034:  * but slightly faster for float/double and some compilers (e.g., gcc), thanks to
        -: 1035:  * specializations when SSE is enabled.
        -: 1036:  *
        -: 1037:  * It's usage is justified in performance critical functions, like norm/normalize.
        -: 1038:  */
        -: 1039:template<typename T>
        -: 1040:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1041:T sqrt(const T &x)
        -: 1042:{
        -: 1043:  EIGEN_USING_STD_MATH(sqrt);
        -: 1044:  return sqrt(x);
        -: 1045:}
        -: 1046:
        -: 1047:template<typename T>
        -: 1048:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1049:T log(const T &x) {
        -: 1050:  EIGEN_USING_STD_MATH(log);
        -: 1051:  return log(x);
        -: 1052:}
        -: 1053:
        -: 1054:#ifdef __CUDACC__
        -: 1055:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1056:float log(const float &x) { return ::logf(x); }
        -: 1057:
        -: 1058:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1059:double log(const double &x) { return ::log(x); }
        -: 1060:#endif
        -: 1061:
        -: 1062:template<typename T>
        -: 1063:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1064:typename NumTraits<T>::Real abs(const T &x) {
        -: 1065:  EIGEN_USING_STD_MATH(abs);
    #####: 1066:  return abs(x);
        -: 1067:}
        -: 1068:
        -: 1069:#ifdef __CUDACC__
        -: 1070:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1071:float abs(const float &x) { return ::fabsf(x); }
        -: 1072:
        -: 1073:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1074:double abs(const double &x) { return ::fabs(x); }
        -: 1075:
        -: 1076:template <> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1077:float abs(const std::complex<float>& x) {
        -: 1078:  return ::hypotf(x.real(), x.imag());
        -: 1079:}
        -: 1080:
        -: 1081:template <> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1082:double abs(const std::complex<double>& x) {
        -: 1083:  return ::hypot(x.real(), x.imag());
        -: 1084:}
        -: 1085:#endif
        -: 1086:
        -: 1087:template<typename T>
        -: 1088:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1089:T exp(const T &x) {
        -: 1090:  EIGEN_USING_STD_MATH(exp);
        -: 1091:  return exp(x);
        -: 1092:}
        -: 1093:
        -: 1094:#ifdef __CUDACC__
        -: 1095:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1096:float exp(const float &x) { return ::expf(x); }
        -: 1097:
        -: 1098:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1099:double exp(const double &x) { return ::exp(x); }
        -: 1100:#endif
        -: 1101:
        -: 1102:template<typename T>
        -: 1103:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1104:T cos(const T &x) {
        -: 1105:  EIGEN_USING_STD_MATH(cos);
        -: 1106:  return cos(x);
        -: 1107:}
        -: 1108:
        -: 1109:#ifdef __CUDACC__
        -: 1110:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1111:float cos(const float &x) { return ::cosf(x); }
        -: 1112:
        -: 1113:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1114:double cos(const double &x) { return ::cos(x); }
        -: 1115:#endif
        -: 1116:
        -: 1117:template<typename T>
        -: 1118:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1119:T sin(const T &x) {
        -: 1120:  EIGEN_USING_STD_MATH(sin);
        -: 1121:  return sin(x);
        -: 1122:}
        -: 1123:
        -: 1124:#ifdef __CUDACC__
        -: 1125:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1126:float sin(const float &x) { return ::sinf(x); }
        -: 1127:
        -: 1128:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1129:double sin(const double &x) { return ::sin(x); }
        -: 1130:#endif
        -: 1131:
        -: 1132:template<typename T>
        -: 1133:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1134:T tan(const T &x) {
        -: 1135:  EIGEN_USING_STD_MATH(tan);
        -: 1136:  return tan(x);
        -: 1137:}
        -: 1138:
        -: 1139:#ifdef __CUDACC__
        -: 1140:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1141:float tan(const float &x) { return ::tanf(x); }
        -: 1142:
        -: 1143:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1144:double tan(const double &x) { return ::tan(x); }
        -: 1145:#endif
        -: 1146:
        -: 1147:template<typename T>
        -: 1148:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1149:T acos(const T &x) {
        -: 1150:  EIGEN_USING_STD_MATH(acos);
        -: 1151:  return acos(x);
        -: 1152:}
        -: 1153:
        -: 1154:#ifdef __CUDACC__
        -: 1155:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1156:float acos(const float &x) { return ::acosf(x); }
        -: 1157:
        -: 1158:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1159:double acos(const double &x) { return ::acos(x); }
        -: 1160:#endif
        -: 1161:
        -: 1162:template<typename T>
        -: 1163:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1164:T asin(const T &x) {
        -: 1165:  EIGEN_USING_STD_MATH(asin);
        -: 1166:  return asin(x);
        -: 1167:}
        -: 1168:
        -: 1169:#ifdef __CUDACC__
        -: 1170:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1171:float asin(const float &x) { return ::asinf(x); }
        -: 1172:
        -: 1173:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1174:double asin(const double &x) { return ::asin(x); }
        -: 1175:#endif
        -: 1176:
        -: 1177:template<typename T>
        -: 1178:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1179:T atan(const T &x) {
        -: 1180:  EIGEN_USING_STD_MATH(atan);
        -: 1181:  return atan(x);
        -: 1182:}
        -: 1183:
        -: 1184:#ifdef __CUDACC__
        -: 1185:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1186:float atan(const float &x) { return ::atanf(x); }
        -: 1187:
        -: 1188:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1189:double atan(const double &x) { return ::atan(x); }
        -: 1190:#endif
        -: 1191:
        -: 1192:
        -: 1193:template<typename T>
        -: 1194:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1195:T cosh(const T &x) {
        -: 1196:  EIGEN_USING_STD_MATH(cosh);
        -: 1197:  return cosh(x);
        -: 1198:}
        -: 1199:
        -: 1200:#ifdef __CUDACC__
        -: 1201:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1202:float cosh(const float &x) { return ::coshf(x); }
        -: 1203:
        -: 1204:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1205:double cosh(const double &x) { return ::cosh(x); }
        -: 1206:#endif
        -: 1207:
        -: 1208:template<typename T>
        -: 1209:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1210:T sinh(const T &x) {
        -: 1211:  EIGEN_USING_STD_MATH(sinh);
        -: 1212:  return sinh(x);
        -: 1213:}
        -: 1214:
        -: 1215:#ifdef __CUDACC__
        -: 1216:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1217:float sinh(const float &x) { return ::sinhf(x); }
        -: 1218:
        -: 1219:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1220:double sinh(const double &x) { return ::sinh(x); }
        -: 1221:#endif
        -: 1222:
        -: 1223:template<typename T>
        -: 1224:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1225:T tanh(const T &x) {
        -: 1226:  EIGEN_USING_STD_MATH(tanh);
        -: 1227:  return tanh(x);
        -: 1228:}
        -: 1229:
        -: 1230:#if (!defined(__CUDACC__)) && EIGEN_FAST_MATH
        -: 1231:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1232:float tanh(float x) { return internal::generic_fast_tanh_float(x); }
        -: 1233:#endif
        -: 1234:
        -: 1235:#ifdef __CUDACC__
        -: 1236:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1237:float tanh(const float &x) { return ::tanhf(x); }
        -: 1238:
        -: 1239:template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1240:double tanh(const double &x) { return ::tanh(x); }
        -: 1241:#endif
        -: 1242:
        -: 1243:template <typename T>
        -: 1244:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1245:T fmod(const T& a, const T& b) {
        -: 1246:  EIGEN_USING_STD_MATH(fmod);
        -: 1247:  return fmod(a, b);
        -: 1248:}
        -: 1249:
        -: 1250:#ifdef __CUDACC__
        -: 1251:template <>
        -: 1252:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1253:float fmod(const float& a, const float& b) {
        -: 1254:  return ::fmodf(a, b);
        -: 1255:}
        -: 1256:
        -: 1257:template <>
        -: 1258:EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
        -: 1259:double fmod(const double& a, const double& b) {
        -: 1260:  return ::fmod(a, b);
        -: 1261:}
        -: 1262:#endif
        -: 1263:
        -: 1264:} // end namespace numext
        -: 1265:
        -: 1266:namespace internal {
        -: 1267:
        -: 1268:template<typename T>
        -: 1269:EIGEN_DEVICE_FUNC bool isfinite_impl(const std::complex<T>& x)
        -: 1270:{
        -: 1271:  return (numext::isfinite)(numext::real(x)) && (numext::isfinite)(numext::imag(x));
        -: 1272:}
        -: 1273:
        -: 1274:template<typename T>
        -: 1275:EIGEN_DEVICE_FUNC bool isnan_impl(const std::complex<T>& x)
        -: 1276:{
        -: 1277:  return (numext::isnan)(numext::real(x)) || (numext::isnan)(numext::imag(x));
        -: 1278:}
        -: 1279:
        -: 1280:template<typename T>
        -: 1281:EIGEN_DEVICE_FUNC bool isinf_impl(const std::complex<T>& x)
        -: 1282:{
        -: 1283:  return ((numext::isinf)(numext::real(x)) || (numext::isinf)(numext::imag(x))) && (!(numext::isnan)(x));
        -: 1284:}
        -: 1285:
        -: 1286:/****************************************************************************
        -: 1287:* Implementation of fuzzy comparisons                                       *
        -: 1288:****************************************************************************/
        -: 1289:
        -: 1290:template<typename Scalar,
        -: 1291:         bool IsComplex,
        -: 1292:         bool IsInteger>
        -: 1293:struct scalar_fuzzy_default_impl {};
        -: 1294:
        -: 1295:template<typename Scalar>
        -: 1296:struct scalar_fuzzy_default_impl<Scalar, false, false>
        -: 1297:{
        -: 1298:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -: 1299:  template<typename OtherScalar> EIGEN_DEVICE_FUNC
    #####: 1300:  static inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y, const RealScalar& prec)
        -: 1301:  {
    #####: 1302:    return numext::abs(x) <= numext::abs(y) * prec;
        -: 1303:  }
        -: 1304:  EIGEN_DEVICE_FUNC
    #####: 1305:  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar& prec)
        -: 1306:  {
    #####: 1307:    return numext::abs(x - y) <= numext::mini(numext::abs(x), numext::abs(y)) * prec;
        -: 1308:  }
        -: 1309:  EIGEN_DEVICE_FUNC
        -: 1310:  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar& prec)
        -: 1311:  {
        -: 1312:    return x <= y || isApprox(x, y, prec);
        -: 1313:  }
        -: 1314:};
        -: 1315:
        -: 1316:template<typename Scalar>
        -: 1317:struct scalar_fuzzy_default_impl<Scalar, false, true>
        -: 1318:{
        -: 1319:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -: 1320:  template<typename OtherScalar> EIGEN_DEVICE_FUNC
        -: 1321:  static inline bool isMuchSmallerThan(const Scalar& x, const Scalar&, const RealScalar&)
        -: 1322:  {
        -: 1323:    return x == Scalar(0);
        -: 1324:  }
        -: 1325:  EIGEN_DEVICE_FUNC
        -: 1326:  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar&)
        -: 1327:  {
        -: 1328:    return x == y;
        -: 1329:  }
        -: 1330:  EIGEN_DEVICE_FUNC
        -: 1331:  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar&)
        -: 1332:  {
        -: 1333:    return x <= y;
        -: 1334:  }
        -: 1335:};
        -: 1336:
        -: 1337:template<typename Scalar>
        -: 1338:struct scalar_fuzzy_default_impl<Scalar, true, false>
        -: 1339:{
        -: 1340:  typedef typename NumTraits<Scalar>::Real RealScalar;
        -: 1341:  template<typename OtherScalar> EIGEN_DEVICE_FUNC
        -: 1342:  static inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y, const RealScalar& prec)
        -: 1343:  {
        -: 1344:    return numext::abs2(x) <= numext::abs2(y) * prec * prec;
        -: 1345:  }
        -: 1346:  EIGEN_DEVICE_FUNC
        -: 1347:  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar& prec)
        -: 1348:  {
        -: 1349:    return numext::abs2(x - y) <= numext::mini(numext::abs2(x), numext::abs2(y)) * prec * prec;
        -: 1350:  }
        -: 1351:};
        -: 1352:
        -: 1353:template<typename Scalar>
        -: 1354:struct scalar_fuzzy_impl : scalar_fuzzy_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};
        -: 1355:
        -: 1356:template<typename Scalar, typename OtherScalar> EIGEN_DEVICE_FUNC
    #####: 1357:inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y,
        -: 1358:                              const typename NumTraits<Scalar>::Real &precision = NumTraits<Scalar>::dummy_precision())
        -: 1359:{
    #####: 1360:  return scalar_fuzzy_impl<Scalar>::template isMuchSmallerThan<OtherScalar>(x, y, precision);
        -: 1361:}
        -: 1362:
        -: 1363:template<typename Scalar> EIGEN_DEVICE_FUNC
    #####: 1364:inline bool isApprox(const Scalar& x, const Scalar& y,
        -: 1365:                     const typename NumTraits<Scalar>::Real &precision = NumTraits<Scalar>::dummy_precision())
        -: 1366:{
    #####: 1367:  return scalar_fuzzy_impl<Scalar>::isApprox(x, y, precision);
        -: 1368:}
        -: 1369:
        -: 1370:template<typename Scalar> EIGEN_DEVICE_FUNC
        -: 1371:inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y,
        -: 1372:                               const typename NumTraits<Scalar>::Real &precision = NumTraits<Scalar>::dummy_precision())
        -: 1373:{
        -: 1374:  return scalar_fuzzy_impl<Scalar>::isApproxOrLessThan(x, y, precision);
        -: 1375:}
        -: 1376:
        -: 1377:/******************************************
        -: 1378:***  The special case of the  bool type ***
        -: 1379:******************************************/
        -: 1380:
        -: 1381:template<> struct random_impl<bool>
        -: 1382:{
        -: 1383:  static inline bool run()
        -: 1384:  {
        -: 1385:    return random<int>(0,1)==0 ? false : true;
        -: 1386:  }
        -: 1387:};
        -: 1388:
        -: 1389:template<> struct scalar_fuzzy_impl<bool>
        -: 1390:{
        -: 1391:  typedef bool RealScalar;
        -: 1392:  
        -: 1393:  template<typename OtherScalar> EIGEN_DEVICE_FUNC
        -: 1394:  static inline bool isMuchSmallerThan(const bool& x, const bool&, const bool&)
        -: 1395:  {
        -: 1396:    return !x;
        -: 1397:  }
        -: 1398:  
        -: 1399:  EIGEN_DEVICE_FUNC
        -: 1400:  static inline bool isApprox(bool x, bool y, bool)
        -: 1401:  {
        -: 1402:    return x == y;
        -: 1403:  }
        -: 1404:
        -: 1405:  EIGEN_DEVICE_FUNC
        -: 1406:  static inline bool isApproxOrLessThan(const bool& x, const bool& y, const bool&)
        -: 1407:  {
        -: 1408:    return (!x) || y;
        -: 1409:  }
        -: 1410:  
        -: 1411:};
        -: 1412:
        -: 1413:  
        -: 1414:} // end namespace internal
        -: 1415:
        -: 1416:} // end namespace Eigen
        -: 1417:
        -: 1418:#endif // EIGEN_MATHFUNCTIONS_H
