        -:    0:Source:/usr/include/eigen3/Eigen/src/Core/DenseBase.h
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:// This file is part of Eigen, a lightweight C++ template library
        -:    2:// for linear algebra.
        -:    3://
        -:    4:// Copyright (C) 2007-2010 Benoit Jacob <jacob.benoit.1@gmail.com>
        -:    5:// Copyright (C) 2008-2010 Gael Guennebaud <gael.guennebaud@inria.fr>
        -:    6://
        -:    7:// This Source Code Form is subject to the terms of the Mozilla
        -:    8:// Public License v. 2.0. If a copy of the MPL was not distributed
        -:    9:// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
        -:   10:
        -:   11:#ifndef EIGEN_DENSEBASE_H
        -:   12:#define EIGEN_DENSEBASE_H
        -:   13:
        -:   14:namespace Eigen {
        -:   15:
        -:   16:namespace internal {
        -:   17:  
        -:   18:// The index type defined by EIGEN_DEFAULT_DENSE_INDEX_TYPE must be a signed type.
        -:   19:// This dummy function simply aims at checking that at compile time.
        -:   20:static inline void check_DenseIndex_is_signed() {
        -:   21:  EIGEN_STATIC_ASSERT(NumTraits<DenseIndex>::IsSigned,THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE); 
        -:   22:}
        -:   23:
        -:   24:} // end namespace internal
        -:   25:  
        -:   26:/** \class DenseBase
        -:   27:  * \ingroup Core_Module
        -:   28:  *
        -:   29:  * \brief Base class for all dense matrices, vectors, and arrays
        -:   30:  *
        -:   31:  * This class is the base that is inherited by all dense objects (matrix, vector, arrays,
        -:   32:  * and related expression types). The common Eigen API for dense objects is contained in this class.
        -:   33:  *
        -:   34:  * \tparam Derived is the derived type, e.g., a matrix type or an expression.
        -:   35:  *
        -:   36:  * This class can be extended with the help of the plugin mechanism described on the page
        -:   37:  * \ref TopicCustomizing_Plugins by defining the preprocessor symbol \c EIGEN_DENSEBASE_PLUGIN.
        -:   38:  *
        -:   39:  * \sa \blank \ref TopicClassHierarchy
        -:   40:  */
        -:   41:template<typename Derived> class DenseBase
        -:   42:#ifndef EIGEN_PARSED_BY_DOXYGEN
        -:   43:  : public DenseCoeffsBase<Derived>
        -:   44:#else
        -:   45:  : public DenseCoeffsBase<Derived,DirectWriteAccessors>
        -:   46:#endif // not EIGEN_PARSED_BY_DOXYGEN
        -:   47:{
        -:   48:  public:
        -:   49:
        -:   50:    /** Inner iterator type to iterate over the coefficients of a row or column.
        -:   51:      * \sa class InnerIterator
        -:   52:      */
        -:   53:    typedef Eigen::InnerIterator<Derived> InnerIterator;
        -:   54:
        -:   55:    typedef typename internal::traits<Derived>::StorageKind StorageKind;
        -:   56:
        -:   57:    /**
        -:   58:      * \brief The type used to store indices
        -:   59:      * \details This typedef is relevant for types that store multiple indices such as
        -:   60:      *          PermutationMatrix or Transpositions, otherwise it defaults to Eigen::Index
        -:   61:      * \sa \blank \ref TopicPreprocessorDirectives, Eigen::Index, SparseMatrixBase.
        -:   62:     */
        -:   63:    typedef typename internal::traits<Derived>::StorageIndex StorageIndex;
        -:   64:
        -:   65:    /** The numeric type of the expression' coefficients, e.g. float, double, int or std::complex<float>, etc. */
        -:   66:    typedef typename internal::traits<Derived>::Scalar Scalar;
        -:   67:    
        -:   68:    /** The numeric type of the expression' coefficients, e.g. float, double, int or std::complex<float>, etc.
        -:   69:      *
        -:   70:      * It is an alias for the Scalar type */
        -:   71:    typedef Scalar value_type;
        -:   72:    
        -:   73:    typedef typename NumTraits<Scalar>::Real RealScalar;
        -:   74:    typedef DenseCoeffsBase<Derived> Base;
        -:   75:
        -:   76:    using Base::derived;
        -:   77:    using Base::const_cast_derived;
        -:   78:    using Base::rows;
        -:   79:    using Base::cols;
        -:   80:    using Base::size;
        -:   81:    using Base::rowIndexByOuterInner;
        -:   82:    using Base::colIndexByOuterInner;
        -:   83:    using Base::coeff;
        -:   84:    using Base::coeffByOuterInner;
        -:   85:    using Base::operator();
        -:   86:    using Base::operator[];
        -:   87:    using Base::x;
        -:   88:    using Base::y;
        -:   89:    using Base::z;
        -:   90:    using Base::w;
        -:   91:    using Base::stride;
        -:   92:    using Base::innerStride;
        -:   93:    using Base::outerStride;
        -:   94:    using Base::rowStride;
        -:   95:    using Base::colStride;
        -:   96:    typedef typename Base::CoeffReturnType CoeffReturnType;
        -:   97:
        -:   98:    enum {
        -:   99:
        -:  100:      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,
        -:  101:        /**< The number of rows at compile-time. This is just a copy of the value provided
        -:  102:          * by the \a Derived type. If a value is not known at compile-time,
        -:  103:          * it is set to the \a Dynamic constant.
        -:  104:          * \sa MatrixBase::rows(), MatrixBase::cols(), ColsAtCompileTime, SizeAtCompileTime */
        -:  105:
        -:  106:      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,
        -:  107:        /**< The number of columns at compile-time. This is just a copy of the value provided
        -:  108:          * by the \a Derived type. If a value is not known at compile-time,
        -:  109:          * it is set to the \a Dynamic constant.
        -:  110:          * \sa MatrixBase::rows(), MatrixBase::cols(), RowsAtCompileTime, SizeAtCompileTime */
        -:  111:
        -:  112:
        -:  113:      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,
        -:  114:                                                   internal::traits<Derived>::ColsAtCompileTime>::ret),
        -:  115:        /**< This is equal to the number of coefficients, i.e. the number of
        -:  116:          * rows times the number of columns, or to \a Dynamic if this is not
        -:  117:          * known at compile-time. \sa RowsAtCompileTime, ColsAtCompileTime */
        -:  118:
        -:  119:      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,
        -:  120:        /**< This value is equal to the maximum possible number of rows that this expression
        -:  121:          * might have. If this expression might have an arbitrarily high number of rows,
        -:  122:          * this value is set to \a Dynamic.
        -:  123:          *
        -:  124:          * This value is useful to know when evaluating an expression, in order to determine
        -:  125:          * whether it is possible to avoid doing a dynamic memory allocation.
        -:  126:          *
        -:  127:          * \sa RowsAtCompileTime, MaxColsAtCompileTime, MaxSizeAtCompileTime
        -:  128:          */
        -:  129:
        -:  130:      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,
        -:  131:        /**< This value is equal to the maximum possible number of columns that this expression
        -:  132:          * might have. If this expression might have an arbitrarily high number of columns,
        -:  133:          * this value is set to \a Dynamic.
        -:  134:          *
        -:  135:          * This value is useful to know when evaluating an expression, in order to determine
        -:  136:          * whether it is possible to avoid doing a dynamic memory allocation.
        -:  137:          *
        -:  138:          * \sa ColsAtCompileTime, MaxRowsAtCompileTime, MaxSizeAtCompileTime
        -:  139:          */
        -:  140:
        -:  141:      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,
        -:  142:                                                      internal::traits<Derived>::MaxColsAtCompileTime>::ret),
        -:  143:        /**< This value is equal to the maximum possible number of coefficients that this expression
        -:  144:          * might have. If this expression might have an arbitrarily high number of coefficients,
        -:  145:          * this value is set to \a Dynamic.
        -:  146:          *
        -:  147:          * This value is useful to know when evaluating an expression, in order to determine
        -:  148:          * whether it is possible to avoid doing a dynamic memory allocation.
        -:  149:          *
        -:  150:          * \sa SizeAtCompileTime, MaxRowsAtCompileTime, MaxColsAtCompileTime
        -:  151:          */
        -:  152:
        -:  153:      IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1
        -:  154:                           || internal::traits<Derived>::MaxColsAtCompileTime == 1,
        -:  155:        /**< This is set to true if either the number of rows or the number of
        -:  156:          * columns is known at compile-time to be equal to 1. Indeed, in that case,
        -:  157:          * we are dealing with a column-vector (if there is only one column) or with
        -:  158:          * a row-vector (if there is only one row). */
        -:  159:
        -:  160:      Flags = internal::traits<Derived>::Flags,
        -:  161:        /**< This stores expression \ref flags flags which may or may not be inherited by new expressions
        -:  162:          * constructed from this one. See the \ref flags "list of flags".
        -:  163:          */
        -:  164:
        -:  165:      IsRowMajor = int(Flags) & RowMajorBit, /**< True if this expression has row-major storage order. */
        -:  166:
        -:  167:      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)
        -:  168:                             : int(IsRowMajor) ? int(ColsAtCompileTime) : int(RowsAtCompileTime),
        -:  169:
        -:  170:      InnerStrideAtCompileTime = internal::inner_stride_at_compile_time<Derived>::ret,
        -:  171:      OuterStrideAtCompileTime = internal::outer_stride_at_compile_time<Derived>::ret
        -:  172:    };
        -:  173:    
        -:  174:    typedef typename internal::find_best_packet<Scalar,SizeAtCompileTime>::type PacketScalar;
        -:  175:
        -:  176:    enum { IsPlainObjectBase = 0 };
        -:  177:    
        -:  178:    /** The plain matrix type corresponding to this expression.
        -:  179:      * \sa PlainObject */
        -:  180:    typedef Matrix<typename internal::traits<Derived>::Scalar,
        -:  181:                internal::traits<Derived>::RowsAtCompileTime,
        -:  182:                internal::traits<Derived>::ColsAtCompileTime,
        -:  183:                AutoAlign | (internal::traits<Derived>::Flags&RowMajorBit ? RowMajor : ColMajor),
        -:  184:                internal::traits<Derived>::MaxRowsAtCompileTime,
        -:  185:                internal::traits<Derived>::MaxColsAtCompileTime
        -:  186:          > PlainMatrix;
        -:  187:    
        -:  188:    /** The plain array type corresponding to this expression.
        -:  189:      * \sa PlainObject */
        -:  190:    typedef Array<typename internal::traits<Derived>::Scalar,
        -:  191:                internal::traits<Derived>::RowsAtCompileTime,
        -:  192:                internal::traits<Derived>::ColsAtCompileTime,
        -:  193:                AutoAlign | (internal::traits<Derived>::Flags&RowMajorBit ? RowMajor : ColMajor),
        -:  194:                internal::traits<Derived>::MaxRowsAtCompileTime,
        -:  195:                internal::traits<Derived>::MaxColsAtCompileTime
        -:  196:          > PlainArray;
        -:  197:
        -:  198:    /** \brief The plain matrix or array type corresponding to this expression.
        -:  199:      *
        -:  200:      * This is not necessarily exactly the return type of eval(). In the case of plain matrices,
        -:  201:      * the return type of eval() is a const reference to a matrix, not a matrix! It is however guaranteed
        -:  202:      * that the return type of eval() is either PlainObject or const PlainObject&.
        -:  203:      */
        -:  204:    typedef typename internal::conditional<internal::is_same<typename internal::traits<Derived>::XprKind,MatrixXpr >::value,
        -:  205:                                 PlainMatrix, PlainArray>::type PlainObject;
        -:  206:
        -:  207:    /** \returns the number of nonzero coefficients which is in practice the number
        -:  208:      * of stored coefficients. */
        -:  209:    EIGEN_DEVICE_FUNC
        -:  210:    inline Index nonZeros() const { return size(); }
        -:  211:
        -:  212:    /** \returns the outer size.
        -:  213:      *
        -:  214:      * \note For a vector, this returns just 1. For a matrix (non-vector), this is the major dimension
        -:  215:      * with respect to the \ref TopicStorageOrders "storage order", i.e., the number of columns for a
        -:  216:      * column-major matrix, and the number of rows for a row-major matrix. */
        -:  217:    EIGEN_DEVICE_FUNC
        -:  218:    Index outerSize() const
        -:  219:    {
        -:  220:      return IsVectorAtCompileTime ? 1
        -:  221:           : int(IsRowMajor) ? this->rows() : this->cols();
        -:  222:    }
        -:  223:
        -:  224:    /** \returns the inner size.
        -:  225:      *
        -:  226:      * \note For a vector, this is just the size. For a matrix (non-vector), this is the minor dimension
        -:  227:      * with respect to the \ref TopicStorageOrders "storage order", i.e., the number of rows for a 
        -:  228:      * column-major matrix, and the number of columns for a row-major matrix. */
        -:  229:    EIGEN_DEVICE_FUNC
    #####:  230:    Index innerSize() const
        -:  231:    {
        -:  232:      return IsVectorAtCompileTime ? this->size()
    #####:  233:           : int(IsRowMajor) ? this->cols() : this->rows();
        -:  234:    }
        -:  235:
        -:  236:    /** Only plain matrices/arrays, not expressions, may be resized; therefore the only useful resize methods are
        -:  237:      * Matrix::resize() and Array::resize(). The present method only asserts that the new size equals the old size, and does
        -:  238:      * nothing else.
        -:  239:      */
        -:  240:    EIGEN_DEVICE_FUNC
        -:  241:    void resize(Index newSize)
        -:  242:    {
        -:  243:      EIGEN_ONLY_USED_FOR_DEBUG(newSize);
        -:  244:      eigen_assert(newSize == this->size()
        -:  245:                && "DenseBase::resize() does not actually allow one to resize.");
        -:  246:    }
        -:  247:    /** Only plain matrices/arrays, not expressions, may be resized; therefore the only useful resize methods are
        -:  248:      * Matrix::resize() and Array::resize(). The present method only asserts that the new size equals the old size, and does
        -:  249:      * nothing else.
        -:  250:      */
        -:  251:    EIGEN_DEVICE_FUNC
    #####:  252:    void resize(Index rows, Index cols)
        -:  253:    {
        -:  254:      EIGEN_ONLY_USED_FOR_DEBUG(rows);
        -:  255:      EIGEN_ONLY_USED_FOR_DEBUG(cols);
    #####:  256:      eigen_assert(rows == this->rows() && cols == this->cols()
        -:  257:                && "DenseBase::resize() does not actually allow one to resize.");
    #####:  258:    }
        -:  259:
        -:  260:#ifndef EIGEN_PARSED_BY_DOXYGEN
        -:  261:    /** \internal Represents a matrix with all coefficients equal to one another*/
        -:  262:    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,PlainObject> ConstantReturnType;
        -:  263:    /** \internal \deprecated Represents a vector with linearly spaced coefficients that allows sequential access only. */
        -:  264:    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,PacketScalar>,PlainObject> SequentialLinSpacedReturnType;
        -:  265:    /** \internal Represents a vector with linearly spaced coefficients that allows random access. */
        -:  266:    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,PacketScalar>,PlainObject> RandomAccessLinSpacedReturnType;
        -:  267:    /** \internal the return type of MatrixBase::eigenvalues() */
        -:  268:    typedef Matrix<typename NumTraits<typename internal::traits<Derived>::Scalar>::Real, internal::traits<Derived>::ColsAtCompileTime, 1> EigenvaluesReturnType;
        -:  269:
        -:  270:#endif // not EIGEN_PARSED_BY_DOXYGEN
        -:  271:
        -:  272:    /** Copies \a other into *this. \returns a reference to *this. */
        -:  273:    template<typename OtherDerived>
        -:  274:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
        -:  275:    Derived& operator=(const DenseBase<OtherDerived>& other);
        -:  276:
        -:  277:    /** Special case of the template operator=, in order to prevent the compiler
        -:  278:      * from generating a default operator= (issue hit with g++ 4.1)
        -:  279:      */
        -:  280:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
        -:  281:    Derived& operator=(const DenseBase& other);
        -:  282:
        -:  283:    template<typename OtherDerived>
        -:  284:    EIGEN_DEVICE_FUNC
        -:  285:    Derived& operator=(const EigenBase<OtherDerived> &other);
        -:  286:
        -:  287:    template<typename OtherDerived>
        -:  288:    EIGEN_DEVICE_FUNC
        -:  289:    Derived& operator+=(const EigenBase<OtherDerived> &other);
        -:  290:
        -:  291:    template<typename OtherDerived>
        -:  292:    EIGEN_DEVICE_FUNC
        -:  293:    Derived& operator-=(const EigenBase<OtherDerived> &other);
        -:  294:
        -:  295:    template<typename OtherDerived>
        -:  296:    EIGEN_DEVICE_FUNC
        -:  297:    Derived& operator=(const ReturnByValue<OtherDerived>& func);
        -:  298:
        -:  299:    /** \ínternal
        -:  300:      * Copies \a other into *this without evaluating other. \returns a reference to *this.
        -:  301:      * \deprecated */
        -:  302:    template<typename OtherDerived>
        -:  303:    EIGEN_DEVICE_FUNC
        -:  304:    Derived& lazyAssign(const DenseBase<OtherDerived>& other);
        -:  305:
        -:  306:    EIGEN_DEVICE_FUNC
        -:  307:    CommaInitializer<Derived> operator<< (const Scalar& s);
        -:  308:
        -:  309:    /** \deprecated it now returns \c *this */
        -:  310:    template<unsigned int Added,unsigned int Removed>
        -:  311:    EIGEN_DEPRECATED
        -:  312:    const Derived& flagged() const
        -:  313:    { return derived(); }
        -:  314:
        -:  315:    template<typename OtherDerived>
        -:  316:    EIGEN_DEVICE_FUNC
        -:  317:    CommaInitializer<Derived> operator<< (const DenseBase<OtherDerived>& other);
        -:  318:
        -:  319:    typedef Transpose<Derived> TransposeReturnType;
        -:  320:    EIGEN_DEVICE_FUNC
        -:  321:    TransposeReturnType transpose();
        -:  322:    typedef typename internal::add_const<Transpose<const Derived> >::type ConstTransposeReturnType;
        -:  323:    EIGEN_DEVICE_FUNC
        -:  324:    ConstTransposeReturnType transpose() const;
        -:  325:    EIGEN_DEVICE_FUNC
        -:  326:    void transposeInPlace();
        -:  327:
        -:  328:    EIGEN_DEVICE_FUNC static const ConstantReturnType
        -:  329:    Constant(Index rows, Index cols, const Scalar& value);
        -:  330:    EIGEN_DEVICE_FUNC static const ConstantReturnType
        -:  331:    Constant(Index size, const Scalar& value);
        -:  332:    EIGEN_DEVICE_FUNC static const ConstantReturnType
        -:  333:    Constant(const Scalar& value);
        -:  334:
        -:  335:    EIGEN_DEVICE_FUNC static const SequentialLinSpacedReturnType
        -:  336:    LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high);
        -:  337:    EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
        -:  338:    LinSpaced(Index size, const Scalar& low, const Scalar& high);
        -:  339:    EIGEN_DEVICE_FUNC static const SequentialLinSpacedReturnType
        -:  340:    LinSpaced(Sequential_t, const Scalar& low, const Scalar& high);
        -:  341:    EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
        -:  342:    LinSpaced(const Scalar& low, const Scalar& high);
        -:  343:
        -:  344:    template<typename CustomNullaryOp> EIGEN_DEVICE_FUNC
        -:  345:    static const CwiseNullaryOp<CustomNullaryOp, PlainObject>
        -:  346:    NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func);
        -:  347:    template<typename CustomNullaryOp> EIGEN_DEVICE_FUNC
        -:  348:    static const CwiseNullaryOp<CustomNullaryOp, PlainObject>
        -:  349:    NullaryExpr(Index size, const CustomNullaryOp& func);
        -:  350:    template<typename CustomNullaryOp> EIGEN_DEVICE_FUNC
        -:  351:    static const CwiseNullaryOp<CustomNullaryOp, PlainObject>
        -:  352:    NullaryExpr(const CustomNullaryOp& func);
        -:  353:
        -:  354:    EIGEN_DEVICE_FUNC static const ConstantReturnType Zero(Index rows, Index cols);
        -:  355:    EIGEN_DEVICE_FUNC static const ConstantReturnType Zero(Index size);
        -:  356:    EIGEN_DEVICE_FUNC static const ConstantReturnType Zero();
        -:  357:    EIGEN_DEVICE_FUNC static const ConstantReturnType Ones(Index rows, Index cols);
        -:  358:    EIGEN_DEVICE_FUNC static const ConstantReturnType Ones(Index size);
        -:  359:    EIGEN_DEVICE_FUNC static const ConstantReturnType Ones();
        -:  360:
        -:  361:    EIGEN_DEVICE_FUNC void fill(const Scalar& value);
        -:  362:    EIGEN_DEVICE_FUNC Derived& setConstant(const Scalar& value);
        -:  363:    EIGEN_DEVICE_FUNC Derived& setLinSpaced(Index size, const Scalar& low, const Scalar& high);
        -:  364:    EIGEN_DEVICE_FUNC Derived& setLinSpaced(const Scalar& low, const Scalar& high);
        -:  365:    EIGEN_DEVICE_FUNC Derived& setZero();
        -:  366:    EIGEN_DEVICE_FUNC Derived& setOnes();
        -:  367:    EIGEN_DEVICE_FUNC Derived& setRandom();
        -:  368:
        -:  369:    template<typename OtherDerived> EIGEN_DEVICE_FUNC
        -:  370:    bool isApprox(const DenseBase<OtherDerived>& other,
        -:  371:                  const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  372:    EIGEN_DEVICE_FUNC 
        -:  373:    bool isMuchSmallerThan(const RealScalar& other,
        -:  374:                           const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  375:    template<typename OtherDerived> EIGEN_DEVICE_FUNC
        -:  376:    bool isMuchSmallerThan(const DenseBase<OtherDerived>& other,
        -:  377:                           const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  378:
        -:  379:    EIGEN_DEVICE_FUNC bool isApproxToConstant(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  380:    EIGEN_DEVICE_FUNC bool isConstant(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  381:    EIGEN_DEVICE_FUNC bool isZero(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  382:    EIGEN_DEVICE_FUNC bool isOnes(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  383:    
        -:  384:    inline bool hasNaN() const;
        -:  385:    inline bool allFinite() const;
        -:  386:
        -:  387:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
        -:  388:    Derived& operator*=(const Scalar& other);
        -:  389:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
        -:  390:    Derived& operator/=(const Scalar& other);
        -:  391:
        -:  392:    typedef typename internal::add_const_on_value_type<typename internal::eval<Derived>::type>::type EvalReturnType;
        -:  393:    /** \returns the matrix or vector obtained by evaluating this expression.
        -:  394:      *
        -:  395:      * Notice that in the case of a plain matrix or vector (not an expression) this function just returns
        -:  396:      * a const reference, in order to avoid a useless copy.
        -:  397:      * 
        -:  398:      * \warning Be carefull with eval() and the auto C++ keyword, as detailed in this \link TopicPitfalls_auto_keyword page \endlink.
        -:  399:      */
        -:  400:    EIGEN_DEVICE_FUNC
    #####:  401:    EIGEN_STRONG_INLINE EvalReturnType eval() const
        -:  402:    {
        -:  403:      // Even though MSVC does not honor strong inlining when the return type
        -:  404:      // is a dynamic matrix, we desperately need strong inlining for fixed
        -:  405:      // size types on MSVC.
    #####:  406:      return typename internal::eval<Derived>::type(derived());
        -:  407:    }
        -:  408:    
        -:  409:    /** swaps *this with the expression \a other.
        -:  410:      *
        -:  411:      */
        -:  412:    template<typename OtherDerived>
        -:  413:    EIGEN_DEVICE_FUNC
        -:  414:    void swap(const DenseBase<OtherDerived>& other)
        -:  415:    {
        -:  416:      EIGEN_STATIC_ASSERT(!OtherDerived::IsPlainObjectBase,THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY);
        -:  417:      eigen_assert(rows()==other.rows() && cols()==other.cols());
        -:  418:      call_assignment(derived(), other.const_cast_derived(), internal::swap_assign_op<Scalar>());
        -:  419:    }
        -:  420:
        -:  421:    /** swaps *this with the matrix or array \a other.
        -:  422:      *
        -:  423:      */
        -:  424:    template<typename OtherDerived>
        -:  425:    EIGEN_DEVICE_FUNC
    #####:  426:    void swap(PlainObjectBase<OtherDerived>& other)
        -:  427:    {
    #####:  428:      eigen_assert(rows()==other.rows() && cols()==other.cols());
    #####:  429:      call_assignment(derived(), other.derived(), internal::swap_assign_op<Scalar>());
    #####:  430:    }
        -:  431:
        -:  432:    EIGEN_DEVICE_FUNC inline const NestByValue<Derived> nestByValue() const;
        -:  433:    EIGEN_DEVICE_FUNC inline const ForceAlignedAccess<Derived> forceAlignedAccess() const;
        -:  434:    EIGEN_DEVICE_FUNC inline ForceAlignedAccess<Derived> forceAlignedAccess();
        -:  435:    template<bool Enable> EIGEN_DEVICE_FUNC
        -:  436:    inline const typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf() const;
        -:  437:    template<bool Enable> EIGEN_DEVICE_FUNC
        -:  438:    inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf();
        -:  439:
        -:  440:    EIGEN_DEVICE_FUNC Scalar sum() const;
        -:  441:    EIGEN_DEVICE_FUNC Scalar mean() const;
        -:  442:    EIGEN_DEVICE_FUNC Scalar trace() const;
        -:  443:
        -:  444:    EIGEN_DEVICE_FUNC Scalar prod() const;
        -:  445:
        -:  446:    EIGEN_DEVICE_FUNC typename internal::traits<Derived>::Scalar minCoeff() const;
        -:  447:    EIGEN_DEVICE_FUNC typename internal::traits<Derived>::Scalar maxCoeff() const;
        -:  448:
        -:  449:    template<typename IndexType> EIGEN_DEVICE_FUNC
        -:  450:    typename internal::traits<Derived>::Scalar minCoeff(IndexType* row, IndexType* col) const;
        -:  451:    template<typename IndexType> EIGEN_DEVICE_FUNC
        -:  452:    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* row, IndexType* col) const;
        -:  453:    template<typename IndexType> EIGEN_DEVICE_FUNC
        -:  454:    typename internal::traits<Derived>::Scalar minCoeff(IndexType* index) const;
        -:  455:    template<typename IndexType> EIGEN_DEVICE_FUNC
        -:  456:    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* index) const;
        -:  457:
        -:  458:    template<typename BinaryOp>
        -:  459:    EIGEN_DEVICE_FUNC
        -:  460:    Scalar redux(const BinaryOp& func) const;
        -:  461:
        -:  462:    template<typename Visitor>
        -:  463:    EIGEN_DEVICE_FUNC
        -:  464:    void visit(Visitor& func) const;
        -:  465:
        -:  466:    inline const WithFormat<Derived> format(const IOFormat& fmt) const;
        -:  467:
        -:  468:    /** \returns the unique coefficient of a 1x1 expression */
        -:  469:    EIGEN_DEVICE_FUNC
        -:  470:    CoeffReturnType value() const
        -:  471:    {
        -:  472:      EIGEN_STATIC_ASSERT_SIZE_1x1(Derived)
        -:  473:      eigen_assert(this->rows() == 1 && this->cols() == 1);
        -:  474:      return derived().coeff(0,0);
        -:  475:    }
        -:  476:
        -:  477:    bool all() const;
        -:  478:    bool any() const;
        -:  479:    Index count() const;
        -:  480:
        -:  481:    typedef VectorwiseOp<Derived, Horizontal> RowwiseReturnType;
        -:  482:    typedef const VectorwiseOp<const Derived, Horizontal> ConstRowwiseReturnType;
        -:  483:    typedef VectorwiseOp<Derived, Vertical> ColwiseReturnType;
        -:  484:    typedef const VectorwiseOp<const Derived, Vertical> ConstColwiseReturnType;
        -:  485:
        -:  486:    /** \returns a VectorwiseOp wrapper of *this providing additional partial reduction operations
        -:  487:    *
        -:  488:    * Example: \include MatrixBase_rowwise.cpp
        -:  489:    * Output: \verbinclude MatrixBase_rowwise.out
        -:  490:    *
        -:  491:    * \sa colwise(), class VectorwiseOp, \ref TutorialReductionsVisitorsBroadcasting
        -:  492:    */
        -:  493:    //Code moved here due to a CUDA compiler bug
        -:  494:    EIGEN_DEVICE_FUNC inline ConstRowwiseReturnType rowwise() const {
        -:  495:      return ConstRowwiseReturnType(derived());
        -:  496:    }
        -:  497:    EIGEN_DEVICE_FUNC RowwiseReturnType rowwise();
        -:  498:
        -:  499:    /** \returns a VectorwiseOp wrapper of *this providing additional partial reduction operations
        -:  500:    *
        -:  501:    * Example: \include MatrixBase_colwise.cpp
        -:  502:    * Output: \verbinclude MatrixBase_colwise.out
        -:  503:    *
        -:  504:    * \sa rowwise(), class VectorwiseOp, \ref TutorialReductionsVisitorsBroadcasting
        -:  505:    */
        -:  506:    EIGEN_DEVICE_FUNC inline ConstColwiseReturnType colwise() const {
        -:  507:      return ConstColwiseReturnType(derived());
        -:  508:    }
        -:  509:    EIGEN_DEVICE_FUNC ColwiseReturnType colwise();
        -:  510:
        -:  511:    typedef CwiseNullaryOp<internal::scalar_random_op<Scalar>,PlainObject> RandomReturnType;
        -:  512:    static const RandomReturnType Random(Index rows, Index cols);
        -:  513:    static const RandomReturnType Random(Index size);
        -:  514:    static const RandomReturnType Random();
        -:  515:
        -:  516:    template<typename ThenDerived,typename ElseDerived>
        -:  517:    const Select<Derived,ThenDerived,ElseDerived>
        -:  518:    select(const DenseBase<ThenDerived>& thenMatrix,
        -:  519:           const DenseBase<ElseDerived>& elseMatrix) const;
        -:  520:
        -:  521:    template<typename ThenDerived>
        -:  522:    inline const Select<Derived,ThenDerived, typename ThenDerived::ConstantReturnType>
        -:  523:    select(const DenseBase<ThenDerived>& thenMatrix, const typename ThenDerived::Scalar& elseScalar) const;
        -:  524:
        -:  525:    template<typename ElseDerived>
        -:  526:    inline const Select<Derived, typename ElseDerived::ConstantReturnType, ElseDerived >
        -:  527:    select(const typename ElseDerived::Scalar& thenScalar, const DenseBase<ElseDerived>& elseMatrix) const;
        -:  528:
        -:  529:    template<int p> RealScalar lpNorm() const;
        -:  530:
        -:  531:    template<int RowFactor, int ColFactor>
        -:  532:    EIGEN_DEVICE_FUNC
        -:  533:    const Replicate<Derived,RowFactor,ColFactor> replicate() const;
        -:  534:    /**
        -:  535:    * \return an expression of the replication of \c *this
        -:  536:    *
        -:  537:    * Example: \include MatrixBase_replicate_int_int.cpp
        -:  538:    * Output: \verbinclude MatrixBase_replicate_int_int.out
        -:  539:    *
        -:  540:    * \sa VectorwiseOp::replicate(), DenseBase::replicate<int,int>(), class Replicate
        -:  541:    */
        -:  542:    //Code moved here due to a CUDA compiler bug
        -:  543:    EIGEN_DEVICE_FUNC
        -:  544:    const Replicate<Derived, Dynamic, Dynamic> replicate(Index rowFactor, Index colFactor) const
        -:  545:    {
        -:  546:      return Replicate<Derived, Dynamic, Dynamic>(derived(), rowFactor, colFactor);
        -:  547:    }
        -:  548:
        -:  549:    typedef Reverse<Derived, BothDirections> ReverseReturnType;
        -:  550:    typedef const Reverse<const Derived, BothDirections> ConstReverseReturnType;
        -:  551:    EIGEN_DEVICE_FUNC ReverseReturnType reverse();
        -:  552:    /** This is the const version of reverse(). */
        -:  553:    //Code moved here due to a CUDA compiler bug
        -:  554:    EIGEN_DEVICE_FUNC ConstReverseReturnType reverse() const
        -:  555:    {
        -:  556:      return ConstReverseReturnType(derived());
        -:  557:    }
        -:  558:    EIGEN_DEVICE_FUNC void reverseInPlace();
        -:  559:
        -:  560:#define EIGEN_CURRENT_STORAGE_BASE_CLASS Eigen::DenseBase
        -:  561:#define EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL
        -:  562:#define EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF(COND)
        -:  563:#   include "../plugins/BlockMethods.h"
        -:  564:#   ifdef EIGEN_DENSEBASE_PLUGIN
        -:  565:#     include EIGEN_DENSEBASE_PLUGIN
        -:  566:#   endif
        -:  567:#undef EIGEN_CURRENT_STORAGE_BASE_CLASS
        -:  568:#undef EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL
        -:  569:#undef EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF
        -:  570:
        -:  571:    // disable the use of evalTo for dense objects with a nice compilation error
        -:  572:    template<typename Dest>
        -:  573:    EIGEN_DEVICE_FUNC
        -:  574:    inline void evalTo(Dest& ) const
        -:  575:    {
        -:  576:      EIGEN_STATIC_ASSERT((internal::is_same<Dest,void>::value),THE_EVAL_EVALTO_FUNCTION_SHOULD_NEVER_BE_CALLED_FOR_DENSE_OBJECTS);
        -:  577:    }
        -:  578:
        -:  579:  protected:
        -:  580:    /** Default constructor. Do nothing. */
    #####:  581:    EIGEN_DEVICE_FUNC DenseBase()
    #####:  582:    {
        -:  583:      /* Just checks for self-consistency of the flags.
        -:  584:       * Only do it when debugging Eigen, as this borders on paranoiac and could slow compilation down
        -:  585:       */
        -:  586:#ifdef EIGEN_INTERNAL_DEBUGGING
        -:  587:      EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, int(IsRowMajor))
        -:  588:                        && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, int(!IsRowMajor))),
        -:  589:                          INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION)
        -:  590:#endif
    #####:  591:    }
        -:  592:
        -:  593:  private:
        -:  594:    EIGEN_DEVICE_FUNC explicit DenseBase(int);
        -:  595:    EIGEN_DEVICE_FUNC DenseBase(int,int);
        -:  596:    template<typename OtherDerived> EIGEN_DEVICE_FUNC explicit DenseBase(const DenseBase<OtherDerived>&);
        -:  597:};
        -:  598:
        -:  599:} // end namespace Eigen
        -:  600:
        -:  601:#endif // EIGEN_DENSEBASE_H
