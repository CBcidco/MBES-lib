        -:    0:Source:test/CoordinateTransformTest.hpp
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*
        -:    2: * Copyright 2017 © Centre Interdisciplinaire de développement en Cartographie des Océans (CIDCO), Tous droits réservés
        -:    3: */
        -:    4:
        -:    5:/*
        -:    6: * File:   CoordinateTransformTest.cpp
        -:    7: * Author: glm,jordan
        -:    8: *
        -:    9: */
        -:   10:
        -:   11:#include "catch.hpp"
        -:   12:#include "../src/math/CoordinateTransform.hpp"
        -:   13:#include <Eigen/Dense>
        -:   14:#include "../src/Position.hpp"
        -:   15:#include <math.h>
        -:   16:
        -:   17:#define POSITION_PRECISION 0.00000001
        -:   18:
        -:   19:/**Test if the coordinate transform works*/
    #####:   20:TEST_CASE("Coordinate Transform Test") {
        -:   21:
        -:   22:    // prime meridian, equator, on ellipsoid
    #####:   23:    Position primeMeridianEquator(0, 0, 0, 0);
        -:   24:
    #####:   25:    Eigen::Vector3d testPositionECEF;
    #####:   26:    CoordinateTransform::getPositionECEF(testPositionECEF,primeMeridianEquator);
        -:   27:
    #####:   28:    Eigen::Vector3d expectedPositionECEF;
    #####:   29:    expectedPositionECEF << 6378137.0 , 0, 0;
        -:   30:
    #####:   31:    REQUIRE( testPositionECEF.isApprox(expectedPositionECEF, POSITION_PRECISION) );
        -:   32:
        -:   33:    // North Pole on ellipsoid
    #####:   34:    Position northPole(0, 90, 0, 0);
    #####:   35:    Eigen::Vector3d northPoleECEF;
    #####:   36:    CoordinateTransform::getPositionECEF(northPoleECEF,northPole);
        -:   37:
    #####:   38:    Eigen::Vector3d expectedNorthPoleECEF;
    #####:   39:    expectedNorthPoleECEF << 0, 0, 6356752.3142; // WGS 84 polar semi-minor axis
        -:   40:
    #####:   41:    double northPolePrecision = 0.00000001;
    #####:   42:    REQUIRE( northPoleECEF.isApprox(expectedNorthPoleECEF, northPolePrecision) );
        -:   43:
        -:   44:    
        -:   45:
    #####:   46:}
        -:   47:
        -:   48:/**test if the conversion between ECEF and longitude latitude height works*/
    #####:   49:TEST_CASE("Conversions between ECEF and Longitude Latitude Height") {
    #####:   50:    Position testPosition(0, 48, -68, 10);
        -:   51:
    #####:   52:    Eigen::Vector3d testPositionECEF;
    #####:   53:    CoordinateTransform::getPositionECEF(testPositionECEF,testPosition);
        -:   54:
    #####:   55:    Position expectedPosition(0,0,0,0);
    #####:   56:    CoordinateTransform::convertECEFToLongitudeLatitudeElevation(testPositionECEF, expectedPosition);
        -:   57:
    #####:   58:    std::cout << "expectedPosition:" << std::endl;
    #####:   59:    std::cout << expectedPosition << std::endl;
        -:   60:
    #####:   61:    REQUIRE(abs((roundf(expectedPosition.getLatitude()*100)/100)-testPosition.getLatitude())<1e-10);
    #####:   62:    REQUIRE(abs((roundf(expectedPosition.getLongitude()*100)/100)-testPosition.getLongitude())<1e-10);
    #####:   63:    REQUIRE(abs((roundf(expectedPosition.getEllipsoidalHeight()*100)/100)-testPosition.getEllipsoidalHeight())<1e-10);
        -:   64:    
    #####:   65:    testPosition = Position(0, 60, 79, -100);
        -:   66:
    #####:   67:    CoordinateTransform::getPositionECEF(testPositionECEF,testPosition);
        -:   68:
    #####:   69:    expectedPosition = Position(0,0,0,0);
    #####:   70:    CoordinateTransform::convertECEFToLongitudeLatitudeElevation(testPositionECEF, expectedPosition);
        -:   71:
    #####:   72:    std::cout << "expectedPosition:" << std::endl;
    #####:   73:    std::cout << expectedPosition << std::endl;
        -:   74:
    #####:   75:    REQUIRE(abs((roundf(expectedPosition.getLatitude()*100)/100)-testPosition.getLatitude())<1e-10);
    #####:   76:    REQUIRE(abs((roundf(expectedPosition.getLongitude()*100)/100)-testPosition.getLongitude())<1e-10);
    #####:   77:    REQUIRE(abs((roundf(expectedPosition.getEllipsoidalHeight()*100)/100)-testPosition.getEllipsoidalHeight())<1e-10);
        -:   78:    
    #####:   79:    testPosition = Position(0, -60, -79, 100);
        -:   80:
    #####:   81:    CoordinateTransform::getPositionECEF(testPositionECEF,testPosition);
        -:   82:
    #####:   83:    expectedPosition = Position(0,0,0,0);
    #####:   84:    CoordinateTransform::convertECEFToLongitudeLatitudeElevation(testPositionECEF, expectedPosition);
        -:   85:
    #####:   86:    std::cout << "expectedPosition:" << std::endl;
    #####:   87:    std::cout << expectedPosition << std::endl;
        -:   88:
    #####:   89:    REQUIRE(abs((roundf(expectedPosition.getLatitude()*100)/100)-testPosition.getLatitude())<1e-10);
    #####:   90:    REQUIRE(abs((roundf(expectedPosition.getLongitude()*100)/100)-testPosition.getLongitude())<1e-10);
    #####:   91:    REQUIRE(abs((roundf(expectedPosition.getEllipsoidalHeight()*100)/100)-testPosition.getEllipsoidalHeight())<1e-10);
        -:   92:    
    #####:   93:    testPosition = Position(0, -70, 48, 90);
        -:   94:
    #####:   95:    CoordinateTransform::getPositionECEF(testPositionECEF,testPosition);
        -:   96:
    #####:   97:    expectedPosition = Position(0,0,0,0);
    #####:   98:    CoordinateTransform::convertECEFToLongitudeLatitudeElevation(testPositionECEF, expectedPosition);
        -:   99:
    #####:  100:    std::cout << "expectedPosition:" << std::endl;
    #####:  101:    std::cout << expectedPosition << std::endl;
        -:  102:
    #####:  103:    REQUIRE(abs((roundf(expectedPosition.getLatitude()*100)/100)-testPosition.getLatitude())<1e-10);
    #####:  104:    REQUIRE(abs((roundf(expectedPosition.getLongitude()*100)/100)-testPosition.getLongitude())<1e-10);
    #####:  105:    REQUIRE(abs((roundf(expectedPosition.getEllipsoidalHeight()*100)/100)-testPosition.getEllipsoidalHeight())<1e-10);
        -:  106:    
    #####:  107:    testPosition = Position(0, 70, 60, 80);
        -:  108:
    #####:  109:    CoordinateTransform::getPositionECEF(testPositionECEF,testPosition);
        -:  110:
    #####:  111:    expectedPosition = Position(0,0,0,0);
    #####:  112:    CoordinateTransform::convertECEFToLongitudeLatitudeElevation(testPositionECEF, expectedPosition);
        -:  113:
    #####:  114:    std::cout << "expectedPosition:" << std::endl;
    #####:  115:    std::cout << expectedPosition << std::endl;
        -:  116:
    #####:  117:    REQUIRE(abs((roundf(expectedPosition.getLatitude()*100)/100)-testPosition.getLatitude())<1e-10);
    #####:  118:    REQUIRE(abs((roundf(expectedPosition.getLongitude()*100)/100)-testPosition.getLongitude())<1e-10);
    #####:  119:    REQUIRE(abs((roundf(expectedPosition.getEllipsoidalHeight()*100)/100)-testPosition.getEllipsoidalHeight())<1e-10);
        -:  120:    
    #####:  121:    testPosition = Position(0, 0, 0, 0);
        -:  122:
    #####:  123:    CoordinateTransform::getPositionECEF(testPositionECEF,testPosition);
        -:  124:
    #####:  125:    expectedPosition = Position(0,0,0,0);
    #####:  126:    CoordinateTransform::convertECEFToLongitudeLatitudeElevation(testPositionECEF, expectedPosition);
        -:  127:
    #####:  128:    std::cout << "expectedPosition:" << std::endl;
    #####:  129:    std::cout << expectedPosition << std::endl;
        -:  130:
    #####:  131:    REQUIRE(abs((roundf(expectedPosition.getLatitude()*100)/100)-testPosition.getLatitude())<1e-10);
    #####:  132:    REQUIRE(abs((roundf(expectedPosition.getLongitude()*100)/100)-testPosition.getLongitude())<1e-10);
    #####:  133:    REQUIRE(abs((roundf(expectedPosition.getEllipsoidalHeight()*100)/100)-testPosition.getEllipsoidalHeight())<1e-10);
        -:  134:    
    #####:  135:    testPosition = Position(0, -80, -40, -50);
        -:  136:
    #####:  137:    CoordinateTransform::getPositionECEF(testPositionECEF,testPosition);
        -:  138:
    #####:  139:    expectedPosition = Position(0,0,0,0);
    #####:  140:    CoordinateTransform::convertECEFToLongitudeLatitudeElevation(testPositionECEF, expectedPosition);
        -:  141:
    #####:  142:    std::cout << "expectedPosition:" << std::endl;
    #####:  143:    std::cout << expectedPosition << std::endl;
        -:  144:
    #####:  145:    REQUIRE(abs((roundf(expectedPosition.getLatitude()*100)/100)-testPosition.getLatitude())<1e-10);
    #####:  146:    REQUIRE(abs((roundf(expectedPosition.getLongitude()*100)/100)-testPosition.getLongitude())<1e-10);
    #####:  147:    REQUIRE(abs((roundf(expectedPosition.getEllipsoidalHeight()*100)/100)-testPosition.getEllipsoidalHeight())<1e-10);
        -:  148:    
    #####:  149:    testPosition = Position(0, 87, -43, -59);
        -:  150:
    #####:  151:    CoordinateTransform::getPositionECEF(testPositionECEF,testPosition);
        -:  152:
    #####:  153:    expectedPosition = Position(0,0,0,0);
    #####:  154:    CoordinateTransform::convertECEFToLongitudeLatitudeElevation(testPositionECEF, expectedPosition);
        -:  155:
    #####:  156:    std::cout << "expectedPosition:" << std::endl;
    #####:  157:    std::cout << expectedPosition << std::endl;
        -:  158:
    #####:  159:    REQUIRE(abs((roundf(expectedPosition.getLatitude()*100)/100)-testPosition.getLatitude())<1e-10);
    #####:  160:    REQUIRE(abs((roundf(expectedPosition.getLongitude()*100)/100)-testPosition.getLongitude())<1e-10);
    #####:  161:    REQUIRE(abs((roundf(expectedPosition.getEllipsoidalHeight()*100)/100)-testPosition.getEllipsoidalHeight())<1e-10);
    #####:  162:}
        -:  163:
        -:  164:/**Test if the conversion between spherical to cartesian works*/
    #####:  165:TEST_CASE("Conversion between spherical to cartesian"){
    #####:  166:    Eigen::Vector3d v;
        -:  167:
    #####:  168:    CoordinateTransform::spherical2cartesian(v,45,45,1);
        -:  169:
    #####:  170:    REQUIRE(abs(v(0) - 0.5) < 0.000000001);
    #####:  171:    REQUIRE(abs(v(1) - 0.5) < 0.000000001);
    #####:  172:    REQUIRE(abs(v(2) - 0.707107) < 0.000001);
    #####:  173:}
        -:  174:
        -:  175:/**Test if the conversion between sonar to cartesian works*/
    #####:  176:TEST_CASE("Conversion between sonar to cartesian"){
    #####:  177:    Eigen::Vector3d v;
        -:  178:
    #####:  179:    REQUIRE(1==2); //TODO FIXME: implementation is dead wrong
    #####:  180:}
        -:  181:
        -:  182:/**Test if the conversion between NED to ECEF position works*/
    #####:  183:TEST_CASE("Conversion between NED to ECEF position")
        -:  184:{
    #####:  185:    Position nedPos(0,0,0,0);
    #####:  186:    Eigen::Matrix3d mECEF;
    #####:  187:    CoordinateTransform::ned2ecef(mECEF,nedPos);
    #####:  188:    Eigen::Matrix3d matrixSearch;
    #####:  189:    matrixSearch << 0,0,-1,
    #####:  190:                    0,1,0,
    #####:  191:                    1,0,0;
    #####:  192:    REQUIRE(mECEF == matrixSearch);
        -:  193:    
    #####:  194:    nedPos = Position(0,16,19,0);
    #####:  195:    CoordinateTransform::ned2ecef(mECEF,nedPos);
    #####:  196:    matrixSearch << -0.260620240054051,-0.325568154457157,-0.908890789521783,
    #####:  197:                    -0.0897387452327910,0.945518575599317,-0.312956196296995,
    #####:  198:                    0.961261695938319,0,-0.275637355816999;
    #####:  199:    REQUIRE(abs(mECEF(0,0)-matrixSearch(0,0))< 1e-10);
    #####:  200:    REQUIRE(abs(mECEF(0,1)-matrixSearch(0,1))< 1e-10);
    #####:  201:    REQUIRE(abs(mECEF(0,2)-matrixSearch(0,2))< 1e-10);
    #####:  202:    REQUIRE(abs(mECEF(1,0)-matrixSearch(1,0))< 1e-10);
    #####:  203:    REQUIRE(abs(mECEF(1,1)-matrixSearch(1,1))< 1e-10);
    #####:  204:    REQUIRE(abs(mECEF(1,2)-matrixSearch(1,2))< 1e-10);
    #####:  205:    REQUIRE(abs(mECEF(2,0)-matrixSearch(2,0))< 1e-10);
    #####:  206:    REQUIRE(abs(mECEF(2,1)-matrixSearch(2,1))< 1e-10);
    #####:  207:    REQUIRE(abs(mECEF(2,2)-matrixSearch(2,2))< 1e-10);
    #####:  208:}
        -:  209:
        -:  210:/**Test if the conversion between Terrestial to Geodetic works*/
    #####:  211:TEST_CASE("Conversion between Terrestial to Geodetic")
        -:  212:{
    #####:  213:    Position pos(0,0,0,0);
    #####:  214:    Eigen::Matrix3d mGeo;
    #####:  215:    CoordinateTransform::getTerrestialToLocalGeodeticReferenceFrameMatrix(mGeo,pos);
    #####:  216:    Eigen::Matrix3d matrixSearch;
    #####:  217:    matrixSearch << 0,0,1,
    #####:  218:                    0,1,0,
    #####:  219:                    -1,0,0;
    #####:  220:    REQUIRE(mGeo == matrixSearch);
        -:  221:    
    #####:  222:    pos = Position(0,45,56,0);
    #####:  223:    CoordinateTransform::getTerrestialToLocalGeodeticReferenceFrameMatrix(mGeo,pos);
    #####:  224:    matrixSearch << -0.395409094035560,-0.586218089412104,0.707106781186548,
    #####:  225:                    -0.829037572555042,0.559192903470747,0,
    #####:  226:                    -0.395409094035560,-0.586218089412104,-0.707106781186548;
    #####:  227:    REQUIRE(abs(mGeo(0,0)-matrixSearch(0,0))< 1e-10);
    #####:  228:    REQUIRE(abs(mGeo(0,1)-matrixSearch(0,1))< 1e-10);
    #####:  229:    REQUIRE(abs(mGeo(0,2)-matrixSearch(0,2))< 1e-10);
    #####:  230:    REQUIRE(abs(mGeo(1,0)-matrixSearch(1,0))< 1e-10);
    #####:  231:    REQUIRE(abs(mGeo(1,1)-matrixSearch(1,1))< 1e-10);
    #####:  232:    REQUIRE(abs(mGeo(1,2)-matrixSearch(1,2))< 1e-10);
    #####:  233:    REQUIRE(abs(mGeo(2,0)-matrixSearch(2,0))< 1e-10);
    #####:  234:    REQUIRE(abs(mGeo(2,1)-matrixSearch(2,1))< 1e-10);
    #####:  235:    REQUIRE(abs(mGeo(2,2)-matrixSearch(2,2))< 1e-10);
    #####:  236:}
        -:  237:
        -:  238:/**Test if CoordinateTransform get a valid DCM*/
    #####:  239:TEST_CASE("getDCM Test") {
        -:  240:
    #####:  241:    Eigen::Vector3d testVector = Eigen::Vector3d::Ones();
        -:  242:
    #####:  243:    Attitude attitudeZero(0, 0, 0, 0);
    #####:  244:    Eigen::Matrix3d dcmAttitudeZero;
    #####:  245:    CoordinateTransform::getDCM(dcmAttitudeZero,attitudeZero);
    #####:  246:    REQUIRE(dcmAttitudeZero.isIdentity());
        -:  247:
        -:  248:    // roll 180 degrees
    #####:  249:    Attitude attitudeRoll(0, 180, 0, 0);
    #####:  250:    Eigen::Matrix3d dcmFromAttitudeRollTest;
    #####:  251:    CoordinateTransform::getDCM(dcmFromAttitudeRollTest,attitudeRoll);
    #####:  252:    Eigen::Vector3d testRollVector = dcmFromAttitudeRollTest * testVector;
        -:  253:
    #####:  254:    double testRollPrecision = 0.000000001;
    #####:  255:    REQUIRE(abs(testRollVector(0) - 1.0) < testRollPrecision);
    #####:  256:    REQUIRE(abs(testRollVector(1) - -1.0) < testRollPrecision);
    #####:  257:    REQUIRE(abs(testRollVector(2) - -1.0) < testRollPrecision);
        -:  258:
        -:  259:    // pitch 180 degrees
    #####:  260:    Attitude attitudePitch(0, 0, 180, 0);
    #####:  261:    Eigen::Matrix3d dcmFromAttitudePitchTest;
    #####:  262:    CoordinateTransform::getDCM(dcmFromAttitudePitchTest,attitudePitch);
    #####:  263:    Eigen::Vector3d testPitchVector = dcmFromAttitudePitchTest * testVector;
        -:  264:
    #####:  265:    double testPitchPrecision = 0.000000001;
    #####:  266:    REQUIRE(abs(testPitchVector(0) - -1.0) < testPitchPrecision);
    #####:  267:    REQUIRE(abs(testPitchVector(1) - 1.0) < testPitchPrecision);
    #####:  268:    REQUIRE(abs(testPitchVector(2) - -1.0) < testPitchPrecision);
        -:  269:
        -:  270:    // heading 180 degrees
    #####:  271:    Attitude attitudeHeading(0, 0, 0, 180);
    #####:  272:    Eigen::Matrix3d dcmFromAttitudeHeadingTest;
    #####:  273:    CoordinateTransform::getDCM(dcmFromAttitudeHeadingTest,attitudeHeading);
    #####:  274:    Eigen::Vector3d testHeadingVector = dcmFromAttitudeHeadingTest * testVector;
        -:  275:
    #####:  276:    double testHeadingPrecision = 0.000000001;
    #####:  277:    REQUIRE(abs(testHeadingVector(0) - -1.0) < testHeadingPrecision);
    #####:  278:    REQUIRE(abs(testHeadingVector(1) - -1.0) < testHeadingPrecision);
    #####:  279:    REQUIRE(abs(testHeadingVector(2) - 1.0) < testHeadingPrecision);
        -:  280:
        -:  281:    // random attitude
    #####:  282:    double roll = 24.357;
    #####:  283:    double pitch = 36.54;
    #####:  284:    double heading = 157.43;
    #####:  285:    Attitude attitudeRandom(0,roll, pitch, heading);
    #####:  286:    Eigen::Matrix3d dcmFromAttitudeRandomTest;
    #####:  287:    CoordinateTransform::getDCM(dcmFromAttitudeRandomTest,attitudeRandom);
        -:  288:
    #####:  289:    Eigen::Matrix3d dcmFromEulerAngles;
    #####:  290:    dcmFromEulerAngles = Eigen::AngleAxisd(heading*D2R, Eigen::Vector3d::UnitZ())
    #####:  291:      * Eigen::AngleAxisd(pitch*D2R, Eigen::Vector3d::UnitY())
    #####:  292:      * Eigen::AngleAxisd(roll*D2R, Eigen::Vector3d::UnitX());
        -:  293:
    #####:  294:    double randomPrecision = 0.000000001;
    #####:  295:    Eigen::Matrix3d dcmDifferences = dcmFromAttitudeRandomTest - dcmFromEulerAngles;
    #####:  296:    dcmDifferences = dcmDifferences.cwiseAbs();
    #####:  297:    REQUIRE(dcmDifferences.maxCoeff() < randomPrecision);
    #####:  298:};
        -:  299:
    #####:  300:TEST_CASE("Test getPositionInNavigationFrame function")
        -:  301:{
    #####:  302:    Eigen::Vector3d posNav;
    #####:  303:    Position pos(0,0,0,0);
    #####:  304:    Eigen::Matrix3d dcm;
    #####:  305:    dcm << 0,0,0,
    #####:  306:           0,0,0,
    #####:  307:           0,0,0;
    #####:  308:    Eigen::Vector3d origin(0,0,0);
    #####:  309:    CoordinateTransform::getPositionInNavigationFrame(posNav,pos,dcm,origin);
    #####:  310:    REQUIRE(posNav(0) == 0);
    #####:  311:    REQUIRE(posNav(1) == 0);
    #####:  312:    REQUIRE(posNav(2) == 0);
        -:  313:    
    #####:  314:    pos = Position(0,180,180,0);
    #####:  315:    dcm << 1,0,0,
    #####:  316:           0,1,0,
    #####:  317:           0,0,1;
    #####:  318:    origin(0) = 0;
    #####:  319:    origin(1) = 0;
    #####:  320:    origin(2) = 0;
    #####:  321:    CoordinateTransform::getPositionInNavigationFrame(posNav,pos,dcm,origin);
    #####:  322:    Eigen::Vector3d vectorSearch(6378137,-0.0000000008,0.0000000008);
    #####:  323:    REQUIRE(abs(posNav(0) - vectorSearch(0))< 1e-10);
    #####:  324:    REQUIRE(abs(posNav(1) - vectorSearch(1))< 1e-10);
    #####:  325:    REQUIRE(abs(posNav(2) - vectorSearch(2))< 1e-10);
    #####:  326:}
